{"ast":null,"code":"var _jsxFileName = \"/Users/pradipbade/Documents/Projects/Small Projects/react-3d-card-game/src/components/Game.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport { cardUtils } from '../utils/cardUtils';\nimport GameSetup from './GameSetup';\nimport GameBoard from './GameBoard';\nimport { textureManager } from '../utils/textureLoader';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function Game() {\n  _s();\n  const [gameState, setGameState] = useState({\n    phase: 'setup',\n    players: [],\n    deck: [],\n    currentPlayerIndex: 0,\n    winner: null,\n    gameLog: [],\n    gameId: Date.now()\n  });\n\n  // Preload all card textures when the component mounts\n  useEffect(() => {\n    // Generate paths for all card textures\n    const cardPaths = [];\n    cardUtils.suits.forEach(suit => {\n      cardUtils.values.forEach(value => {\n        cardPaths.push(`/assets/cards/faces/${suit}/${value}.png`);\n      });\n    });\n\n    // Add card back texture\n    cardPaths.push('/assets/cards/backs/cardback.png');\n\n    // Preload all textures\n    textureManager.preloadTextures(cardPaths);\n\n    // Clean up textures when component unmounts\n    return () => {\n      textureManager.clearCache();\n    };\n  }, []);\n  // Initialize the game with the selected number of players\n  const setupGame = numPlayers => {\n    let deck = cardUtils.shuffle(cardUtils.generateDeck());\n    const players = [];\n    const initialLog = ['Game started!'];\n\n    // Pre-load card textures for better performance and to avoid loading issues\n    const textureCache = {};\n\n    // Create players (1 human + bots)\n    for (let i = 0; i < numPlayers; i++) {\n      const playerName = i === 0 ? 'You' : `Bot ${i}`;\n      const {\n        drawn,\n        remaining\n      } = cardUtils.drawCards(deck, 1);\n      const drawnCard = drawn[0];\n      deck = remaining; // Update the deck after each draw\n\n      // Create player with initial card\n      const player = {\n        id: i,\n        name: playerName,\n        isHuman: i === 0,\n        cards: [...drawn],\n        hiddenCards: i === 0 ? [] : [...drawn],\n        // For bots, initial card is hidden\n        visibleCards: i === 0 ? [...drawn] : [],\n        // For human, initial card is visible\n        total: cardUtils.calculateTotal(drawn),\n        status: 'active' // active, holding, eliminated, winner\n      };\n      players.push(player);\n\n      // Log the initial card draw - for human we show the card, for bots we just log that they drew a card\n      if (i === 0) {\n        initialLog.push(`You drew ${cardUtils.getCardName(drawnCard)}. Total: ${player.total}`);\n      } else {\n        initialLog.push(`${playerName} drew a card.`);\n      }\n    }\n    initialLog.push(\"Your turn.\");\n    setGameState({\n      phase: 'playing',\n      players,\n      deck,\n      // Store the updated deck after dealing all initial cards\n      currentPlayerIndex: 0,\n      winner: null,\n      gameLog: initialLog,\n      gameId: Date.now(),\n      // Generate new game ID\n      textureCache\n    });\n  };\n\n  // Handle player's decision to draw a card\n  // Update the handleDrawCard function to ensure one player completes their turn before moving to the next\n\n  const handleDrawCard = () => {\n    if (gameState.phase !== 'playing') return;\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n    if (!currentPlayer || currentPlayer.status !== 'active') return;\n\n    // Draw a card from the deck\n    const {\n      drawn,\n      remaining\n    } = cardUtils.drawCards(gameState.deck, 1);\n    const drawnCard = drawn[0];\n\n    // Update player's cards and total\n    const updatedPlayers = [...gameState.players];\n    const player = updatedPlayers[gameState.currentPlayerIndex];\n    player.cards = [...player.cards, drawnCard];\n    player.visibleCards = [...player.visibleCards, drawnCard];\n    player.total = cardUtils.calculateTotal(player.cards);\n\n    // Log the action\n    const actionLog = `${player.name} drew ${drawnCard.value} of ${drawnCard.suit}. Total: ${player.total}`;\n\n    // Check if player reached 17\n    if (player.total === 17) {\n      player.status = 'winner';\n      setGameState({\n        ...gameState,\n        players: updatedPlayers,\n        deck: remaining,\n        phase: 'gameOver',\n        winner: gameState.currentPlayerIndex,\n        gameLog: [...gameState.gameLog, actionLog, `${player.name} won with exactly 17!`]\n      });\n      return;\n    }\n\n    // Check if player exceeded 17\n    if (player.total > 17) {\n      player.status = 'eliminated';\n\n      // Check if all players are eliminated or if the game is over\n      const gameEndCheck = checkGameEnd(updatedPlayers, `${player.name} exceeded 17 and is eliminated!`);\n      if (gameEndCheck.gameOver) {\n        setGameState({\n          ...gameState,\n          players: gameEndCheck.players,\n          deck: remaining,\n          phase: 'revealing',\n          // Set to revealing phase instead of gameOver\n          revealPhase: true,\n          pendingWinner: gameEndCheck.winner,\n          // Store the winner temporarily\n          pendingWinnerMessage: gameEndCheck.winnerMessage,\n          gameLog: [...gameState.gameLog, actionLog, ...gameEndCheck.message]\n        });\n        return;\n      }\n\n      // Find next active player\n      let nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\n      while (nextPlayerIndex !== gameState.currentPlayerIndex && (updatedPlayers[nextPlayerIndex].status === 'eliminated' || updatedPlayers[nextPlayerIndex].status === 'holding')) {\n        nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;\n      }\n      setGameState({\n        ...gameState,\n        players: updatedPlayers,\n        deck: remaining,\n        currentPlayerIndex: nextPlayerIndex,\n        gameLog: [...gameState.gameLog, actionLog, `${player.name} exceeded 17 and is eliminated!`, `${updatedPlayers[nextPlayerIndex].name}'s turn.`]\n      });\n      return;\n    }\n\n    // If player's total is less than 11, they must continue drawing\n    const mustContinue = player.total < 11;\n    if (mustContinue) {\n      // Player must continue drawing\n      setGameState({\n        ...gameState,\n        players: updatedPlayers,\n        deck: remaining,\n        gameLog: [...gameState.gameLog, actionLog]\n      });\n    } else if (player.isHuman) {\n      // Human player can choose to draw again or hold\n      setGameState({\n        ...gameState,\n        players: updatedPlayers,\n        deck: remaining,\n        gameLog: [...gameState.gameLog, actionLog]\n      });\n    } else {\n      // For bots, decide whether to draw or hold in the useEffect\n      setGameState({\n        ...gameState,\n        players: updatedPlayers,\n        deck: remaining,\n        gameLog: [...gameState.gameLog, actionLog]\n      });\n    }\n  };\n\n  // Handle player's decision to hold\n  const handleHold = () => {\n    if (gameState.phase !== 'playing') return;\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n    if (!currentPlayer || !currentPlayer.isHuman || currentPlayer.status !== 'active') return;\n\n    // Check if player is allowed to hold (total must be 11-16)\n    if (currentPlayer.total < 11) {\n      setGameState({\n        ...gameState,\n        gameLog: [...gameState.gameLog, 'You must draw until you reach at least 11.']\n      });\n      return;\n    }\n    const updatedPlayers = [...gameState.players];\n    updatedPlayers[gameState.currentPlayerIndex].status = 'holding';\n\n    // Find next active player\n    let nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\n    while (nextPlayerIndex !== gameState.currentPlayerIndex && (updatedPlayers[nextPlayerIndex].status === 'eliminated' || updatedPlayers[nextPlayerIndex].status === 'holding')) {\n      nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;\n    }\n\n    // Check if all players are holding or eliminated\n    const allDone = updatedPlayers.every(p => p.status !== 'active');\n    if (allDone) {\n      // Find winner with highest total not exceeding 17\n      let maxTotal = 0;\n      let winnerIndex = -1;\n      updatedPlayers.forEach((p, idx) => {\n        if (p.status !== 'eliminated' && p.total <= 17 && p.total > maxTotal) {\n          maxTotal = p.total;\n          winnerIndex = idx;\n        }\n      });\n      if (winnerIndex !== -1) {\n        updatedPlayers[winnerIndex].status = 'winner';\n        setGameState({\n          ...gameState,\n          players: updatedPlayers,\n          phase: 'gameOver',\n          winner: winnerIndex,\n          gameLog: [...gameState.gameLog, `You decided to hold with a total of ${currentPlayer.total}.`, `${updatedPlayers[winnerIndex].name} wins with a total of ${maxTotal}!`]\n        });\n        return;\n      }\n    }\n    setGameState({\n      ...gameState,\n      players: updatedPlayers,\n      currentPlayerIndex: nextPlayerIndex,\n      gameLog: [...gameState.gameLog, `You decided to hold with a total of ${currentPlayer.total}.`, `${updatedPlayers[nextPlayerIndex].name}'s turn.`]\n    });\n  };\n\n  // Add this function inside your Game component, before the return statement\n  const determineWinner = players => {\n    // Return early if any player has already won with exactly 17\n    const exactWinner = players.findIndex(p => p.total === 17);\n    if (exactWinner !== -1) {\n      return {\n        winnerIndex: exactWinner,\n        winMessage: `${players[exactWinner].name} won with exactly 17!`\n      };\n    }\n\n    // Check if all players are eliminated\n    const allEliminated = players.every(p => p.status === 'eliminated');\n    if (allEliminated) {\n      return {\n        winnerIndex: -1,\n        winMessage: 'All players exceeded 17. Game is void.'\n      };\n    }\n\n    // Find player with highest total not exceeding 17\n    let maxTotal = 0;\n    let winnerIndex = -1;\n    players.forEach((player, idx) => {\n      if (player.status !== 'eliminated' && player.total <= 17 && player.total > maxTotal) {\n        maxTotal = player.total;\n        winnerIndex = idx;\n      }\n    });\n    if (winnerIndex !== -1) {\n      return {\n        winnerIndex,\n        winMessage: `${players[winnerIndex].name} wins with a total of ${maxTotal}!`\n      };\n    }\n\n    // No winner could be determined (should never happen if game logic is correct)\n    return {\n      winnerIndex: -1,\n      winMessage: 'No winner could be determined.'\n    };\n  };\n\n  // Add this function to check if the game is over\n  // Modify the checkGameEnd function to add a reveal phase\n  const checkGameEnd = (updatedPlayers, currentAction = \"\") => {\n    // Check if game should end (all players are holding or eliminated)\n    const allDone = updatedPlayers.every(p => p.status !== 'active');\n    if (allDone) {\n      // Determine winner, but don't set the winner status yet\n      const {\n        winnerIndex,\n        winMessage\n      } = determineWinner(updatedPlayers);\n\n      // We'll set all players to 'revealing' status first\n      updatedPlayers.forEach(player => {\n        if (player.status !== 'eliminated') {\n          player.status = 'revealing';\n        }\n      });\n      return {\n        gameOver: true,\n        revealPhase: true,\n        // Add a reveal phase flag\n        players: updatedPlayers,\n        winner: winnerIndex,\n        winnerMessage: winMessage,\n        message: [currentAction].filter(Boolean) // Only include the current action\n      };\n    }\n    return {\n      gameOver: false\n    };\n  };\n\n  // Update the bot decision-making logic in the useEffect\n\n  useEffect(() => {\n    if (gameState.phase !== 'playing') return;\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n    if (!currentPlayer || currentPlayer.isHuman || currentPlayer.status !== 'active') return;\n    const botTurn = setTimeout(() => {\n      // Get visible cards of other players (excluding first cards of bots)\n      const otherPlayersVisibleCards = gameState.players.map((player, index) => {\n        if (index === gameState.currentPlayerIndex) return [];\n        return player.visibleCards;\n      }).filter(cards => cards.length > 0);\n\n      // Force bot to draw at least one card after their initial hidden card\n      // A player should have at least 2 cards total (1 hidden + 1 visible)\n      const mustDrawFirstCard = currentPlayer.cards.length <= 1;\n\n      // Decide whether to draw or hold\n      if (mustDrawFirstCard || currentPlayer.total < 11 || cardUtils.shouldBotDraw(currentPlayer.cards, otherPlayersVisibleCards)) {\n        handleDrawCard();\n      } else {\n        // Bot decides to hold\n        const updatedPlayers = [...gameState.players];\n        updatedPlayers[gameState.currentPlayerIndex].status = 'holding';\n\n        // Find next active player\n        let nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\n        while (nextPlayerIndex !== gameState.currentPlayerIndex && (updatedPlayers[nextPlayerIndex].status === 'eliminated' || updatedPlayers[nextPlayerIndex].status === 'holding')) {\n          nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;\n        }\n\n        // Check if all players are holding or eliminated\n        const allDone = updatedPlayers.every(p => p.status !== 'active');\n        if (allDone) {\n          // Check if game should end using the shared game end logic\n          const gameEndCheck = checkGameEnd(updatedPlayers, `${currentPlayer.name} decided to hold with a total of ${currentPlayer.total}.`);\n          if (gameEndCheck.gameOver) {\n            setGameState({\n              ...gameState,\n              players: gameEndCheck.players,\n              deck: gameState.deck,\n              phase: 'revealing',\n              revealPhase: true,\n              pendingWinner: gameEndCheck.winner,\n              pendingWinnerMessage: gameEndCheck.winnerMessage,\n              gameLog: [...gameState.gameLog, ...gameEndCheck.message]\n            });\n            return;\n          }\n        }\n        setGameState({\n          ...gameState,\n          players: updatedPlayers,\n          currentPlayerIndex: nextPlayerIndex,\n          gameLog: [...gameState.gameLog, `${currentPlayer.name} decided to hold with a total of ${currentPlayer.total}.`, `${updatedPlayers[nextPlayerIndex].name}'s turn.`]\n        });\n      }\n    }, 1000); // 1 second delay for bot actions\n\n    return () => clearTimeout(botTurn);\n  }, [gameState]);\n\n  // Add this useEffect to handle the reveal phase\n  useEffect(() => {\n    // Only run this effect when we're in the revealing phase\n    if (gameState.phase === 'revealing' && gameState.revealPhase) {\n      const revealTimer = setTimeout(() => {\n        const updatedPlayers = [...gameState.players];\n\n        // After revealing, set the winner status\n        if (gameState.pendingWinner !== -1) {\n          updatedPlayers[gameState.pendingWinner].status = 'winner';\n        }\n        setGameState({\n          ...gameState,\n          players: updatedPlayers,\n          phase: 'gameOver',\n          revealPhase: false,\n          winner: gameState.pendingWinner,\n          gameLog: [...gameState.gameLog, gameState.pendingWinnerMessage]\n        });\n      }, 500); // 2 second delay to allow players to see all cards\n\n      return () => clearTimeout(revealTimer);\n    }\n  }, [gameState.phase, gameState.revealPhase]);\n\n  // Use this function to reset the game and ensure all textures are reloaded\n  const resetGame = () => {\n    // Reset the game with the same number of players\n    const numPlayers = gameState.players.length;\n\n    // Clear any cached textures\n    THREE.Cache.clear();\n\n    // Force a slight delay to ensure cleanup happens\n    setTimeout(() => {\n      setupGame(numPlayers);\n    }, 50);\n  };\n  const returnToHome = () => {\n    // Reset everything and return to setup phase\n    setGameState({\n      phase: 'setup',\n      players: [],\n      deck: [],\n      currentPlayerIndex: 0,\n      winner: null,\n      gameLog: []\n    });\n  };\n  // In your return statement, pass the gameId to GameBoard:\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"game-container\",\n    children: gameState.phase === 'setup' ? /*#__PURE__*/_jsxDEV(GameSetup, {\n      onSetupComplete: setupGame\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 485,\n      columnNumber: 17\n    }, this) : /*#__PURE__*/_jsxDEV(GameBoard, {\n      gameState: gameState,\n      onDrawCard: handleDrawCard,\n      onHold: handleHold,\n      onReset: resetGame,\n      onReturnHome: returnToHome\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 487,\n      columnNumber: 17\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 483,\n    columnNumber: 9\n  }, this);\n}\n_s(Game, \"/MsyCUgaIGzpeRSR5C5NW/n0Jy0=\");\n_c = Game;\nvar _c;\n$RefreshReg$(_c, \"Game\");","map":{"version":3,"names":["React","useState","useEffect","cardUtils","GameSetup","GameBoard","textureManager","jsxDEV","_jsxDEV","Game","_s","gameState","setGameState","phase","players","deck","currentPlayerIndex","winner","gameLog","gameId","Date","now","cardPaths","suits","forEach","suit","values","value","push","preloadTextures","clearCache","setupGame","numPlayers","shuffle","generateDeck","initialLog","textureCache","i","playerName","drawn","remaining","drawCards","drawnCard","player","id","name","isHuman","cards","hiddenCards","visibleCards","total","calculateTotal","status","getCardName","handleDrawCard","currentPlayer","updatedPlayers","actionLog","gameEndCheck","checkGameEnd","gameOver","revealPhase","pendingWinner","pendingWinnerMessage","winnerMessage","message","nextPlayerIndex","length","mustContinue","handleHold","allDone","every","p","maxTotal","winnerIndex","idx","determineWinner","exactWinner","findIndex","winMessage","allEliminated","currentAction","filter","Boolean","botTurn","setTimeout","otherPlayersVisibleCards","map","index","mustDrawFirstCard","shouldBotDraw","clearTimeout","revealTimer","resetGame","THREE","Cache","clear","returnToHome","className","children","onSetupComplete","fileName","_jsxFileName","lineNumber","columnNumber","onDrawCard","onHold","onReset","onReturnHome","_c","$RefreshReg$"],"sources":["/Users/pradipbade/Documents/Projects/Small Projects/react-3d-card-game/src/components/Game.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport { cardUtils } from '../utils/cardUtils';\nimport GameSetup from './GameSetup';\nimport GameBoard from './GameBoard';\nimport { textureManager } from '../utils/textureLoader';\n\nexport default function Game() {\n    const [gameState, setGameState] = useState({\n        phase: 'setup',\n        players: [],\n        deck: [],\n        currentPlayerIndex: 0,\n        winner: null,\n        gameLog: [],\n        gameId: Date.now()\n    });\n\n// Preload all card textures when the component mounts\n    useEffect(() => {\n        // Generate paths for all card textures\n        const cardPaths = [];\n        cardUtils.suits.forEach(suit => {\n            cardUtils.values.forEach(value => {\n                cardPaths.push(`/assets/cards/faces/${suit}/${value}.png`);\n            });\n        });\n        \n        // Add card back texture\n        cardPaths.push('/assets/cards/backs/cardback.png');\n        \n        // Preload all textures\n        textureManager.preloadTextures(cardPaths);\n        \n        // Clean up textures when component unmounts\n        return () => {\n            textureManager.clearCache();\n        };\n    }, []);\n    // Initialize the game with the selected number of players\n    const setupGame = (numPlayers) => {\n        let deck = cardUtils.shuffle(cardUtils.generateDeck());\n        const players = [];\n        const initialLog = ['Game started!'];\n\n        // Pre-load card textures for better performance and to avoid loading issues\n        const textureCache = {};\n\n        // Create players (1 human + bots)\n        for (let i = 0; i < numPlayers; i++) {\n            const playerName = i === 0 ? 'You' : `Bot ${i}`;\n            const { drawn, remaining } = cardUtils.drawCards(deck, 1);\n            const drawnCard = drawn[0];\n            deck = remaining; // Update the deck after each draw\n\n            // Create player with initial card\n            const player = {\n                id: i,\n                name: playerName,\n                isHuman: i === 0,\n                cards: [...drawn],\n                hiddenCards: i === 0 ? [] : [...drawn], // For bots, initial card is hidden\n                visibleCards: i === 0 ? [...drawn] : [], // For human, initial card is visible\n                total: cardUtils.calculateTotal(drawn),\n                status: 'active' // active, holding, eliminated, winner\n            };\n\n            players.push(player);\n\n            // Log the initial card draw - for human we show the card, for bots we just log that they drew a card\n            if (i === 0) {\n                initialLog.push(`You drew ${cardUtils.getCardName(drawnCard)}. Total: ${player.total}`);\n            } else {\n                initialLog.push(`${playerName} drew a card.`);\n            }\n        }\n\n        initialLog.push(\"Your turn.\");\n\n        setGameState({\n            phase: 'playing',\n            players,\n            deck, // Store the updated deck after dealing all initial cards\n            currentPlayerIndex: 0,\n            winner: null,\n            gameLog: initialLog,\n            gameId: Date.now(), // Generate new game ID\n            textureCache\n        });\n    };\n\n    // Handle player's decision to draw a card\n    // Update the handleDrawCard function to ensure one player completes their turn before moving to the next\n\n    const handleDrawCard = () => {\n        if (gameState.phase !== 'playing') return;\n\n        const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n        if (!currentPlayer || currentPlayer.status !== 'active') return;\n\n        // Draw a card from the deck\n        const { drawn, remaining } = cardUtils.drawCards(gameState.deck, 1);\n        const drawnCard = drawn[0];\n\n        // Update player's cards and total\n        const updatedPlayers = [...gameState.players];\n        const player = updatedPlayers[gameState.currentPlayerIndex];\n\n        player.cards = [...player.cards, drawnCard];\n        player.visibleCards = [...player.visibleCards, drawnCard];\n        player.total = cardUtils.calculateTotal(player.cards);\n\n        // Log the action\n        const actionLog = `${player.name} drew ${drawnCard.value} of ${drawnCard.suit}. Total: ${player.total}`;\n\n        // Check if player reached 17\n        if (player.total === 17) {\n            player.status = 'winner';\n\n            setGameState({\n                ...gameState,\n                players: updatedPlayers,\n                deck: remaining,\n                phase: 'gameOver',\n                winner: gameState.currentPlayerIndex,\n                gameLog: [...gameState.gameLog, actionLog, `${player.name} won with exactly 17!`]\n            });\n            return;\n        }\n\n        // Check if player exceeded 17\n        if (player.total > 17) {\n            player.status = 'eliminated';\n\n            // Check if all players are eliminated or if the game is over\n            const gameEndCheck = checkGameEnd(updatedPlayers,\n                `${player.name} exceeded 17 and is eliminated!`);\n\n            if (gameEndCheck.gameOver) {\n                setGameState({\n                    ...gameState,\n                    players: gameEndCheck.players,\n                    deck: remaining,\n                    phase: 'revealing', // Set to revealing phase instead of gameOver\n                    revealPhase: true,\n                    pendingWinner: gameEndCheck.winner, // Store the winner temporarily\n                    pendingWinnerMessage: gameEndCheck.winnerMessage,\n                    gameLog: [...gameState.gameLog, actionLog, ...gameEndCheck.message]\n                });\n                return;\n            }\n\n            // Find next active player\n            let nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\n            while (\n                nextPlayerIndex !== gameState.currentPlayerIndex &&\n                (updatedPlayers[nextPlayerIndex].status === 'eliminated' ||\n                    updatedPlayers[nextPlayerIndex].status === 'holding')\n            ) {\n                nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;\n            }\n\n            setGameState({\n                ...gameState,\n                players: updatedPlayers,\n                deck: remaining,\n                currentPlayerIndex: nextPlayerIndex,\n                gameLog: [...gameState.gameLog, actionLog,\n                `${player.name} exceeded 17 and is eliminated!`,\n                `${updatedPlayers[nextPlayerIndex].name}'s turn.`]\n            });\n            return;\n        }\n\n        // If player's total is less than 11, they must continue drawing\n        const mustContinue = player.total < 11;\n\n        if (mustContinue) {\n            // Player must continue drawing\n            setGameState({\n                ...gameState,\n                players: updatedPlayers,\n                deck: remaining,\n                gameLog: [...gameState.gameLog, actionLog]\n            });\n        } else if (player.isHuman) {\n            // Human player can choose to draw again or hold\n            setGameState({\n                ...gameState,\n                players: updatedPlayers,\n                deck: remaining,\n                gameLog: [...gameState.gameLog, actionLog]\n            });\n        } else {\n            // For bots, decide whether to draw or hold in the useEffect\n            setGameState({\n                ...gameState,\n                players: updatedPlayers,\n                deck: remaining,\n                gameLog: [...gameState.gameLog, actionLog]\n            });\n        }\n    };\n\n    // Handle player's decision to hold\n    const handleHold = () => {\n        if (gameState.phase !== 'playing') return;\n\n        const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n        if (!currentPlayer || !currentPlayer.isHuman || currentPlayer.status !== 'active') return;\n\n        // Check if player is allowed to hold (total must be 11-16)\n        if (currentPlayer.total < 11) {\n            setGameState({\n                ...gameState,\n                gameLog: [...gameState.gameLog, 'You must draw until you reach at least 11.']\n            });\n            return;\n        }\n\n        const updatedPlayers = [...gameState.players];\n        updatedPlayers[gameState.currentPlayerIndex].status = 'holding';\n\n        // Find next active player\n        let nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\n        while (\n            nextPlayerIndex !== gameState.currentPlayerIndex &&\n            (updatedPlayers[nextPlayerIndex].status === 'eliminated' ||\n                updatedPlayers[nextPlayerIndex].status === 'holding')\n        ) {\n            nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;\n        }\n\n        // Check if all players are holding or eliminated\n        const allDone = updatedPlayers.every(p => p.status !== 'active');\n\n        if (allDone) {\n            // Find winner with highest total not exceeding 17\n            let maxTotal = 0;\n            let winnerIndex = -1;\n\n            updatedPlayers.forEach((p, idx) => {\n                if (p.status !== 'eliminated' && p.total <= 17 && p.total > maxTotal) {\n                    maxTotal = p.total;\n                    winnerIndex = idx;\n                }\n            });\n\n            if (winnerIndex !== -1) {\n                updatedPlayers[winnerIndex].status = 'winner';\n\n                setGameState({\n                    ...gameState,\n                    players: updatedPlayers,\n                    phase: 'gameOver',\n                    winner: winnerIndex,\n                    gameLog: [...gameState.gameLog,\n                    `You decided to hold with a total of ${currentPlayer.total}.`,\n                    `${updatedPlayers[winnerIndex].name} wins with a total of ${maxTotal}!`\n                    ]\n                });\n                return;\n            }\n        }\n\n        setGameState({\n            ...gameState,\n            players: updatedPlayers,\n            currentPlayerIndex: nextPlayerIndex,\n            gameLog: [...gameState.gameLog,\n            `You decided to hold with a total of ${currentPlayer.total}.`,\n            `${updatedPlayers[nextPlayerIndex].name}'s turn.`\n            ]\n        });\n    };\n\n\n    // Add this function inside your Game component, before the return statement\n    const determineWinner = (players) => {\n        // Return early if any player has already won with exactly 17\n        const exactWinner = players.findIndex(p => p.total === 17);\n        if (exactWinner !== -1) {\n            return {\n                winnerIndex: exactWinner,\n                winMessage: `${players[exactWinner].name} won with exactly 17!`\n            };\n        }\n\n        // Check if all players are eliminated\n        const allEliminated = players.every(p => p.status === 'eliminated');\n        if (allEliminated) {\n            return {\n                winnerIndex: -1,\n                winMessage: 'All players exceeded 17. Game is void.'\n            };\n        }\n\n        // Find player with highest total not exceeding 17\n        let maxTotal = 0;\n        let winnerIndex = -1;\n\n        players.forEach((player, idx) => {\n            if (player.status !== 'eliminated' && player.total <= 17 && player.total > maxTotal) {\n                maxTotal = player.total;\n                winnerIndex = idx;\n            }\n        });\n\n        if (winnerIndex !== -1) {\n            return {\n                winnerIndex,\n                winMessage: `${players[winnerIndex].name} wins with a total of ${maxTotal}!`\n            };\n        }\n\n        // No winner could be determined (should never happen if game logic is correct)\n        return {\n            winnerIndex: -1,\n            winMessage: 'No winner could be determined.'\n        };\n    };\n\n    // Add this function to check if the game is over\n    // Modify the checkGameEnd function to add a reveal phase\n    const checkGameEnd = (updatedPlayers, currentAction = \"\") => {\n        // Check if game should end (all players are holding or eliminated)\n        const allDone = updatedPlayers.every(p => p.status !== 'active');\n\n        if (allDone) {\n            // Determine winner, but don't set the winner status yet\n            const { winnerIndex, winMessage } = determineWinner(updatedPlayers);\n\n            // We'll set all players to 'revealing' status first\n            updatedPlayers.forEach(player => {\n                if (player.status !== 'eliminated') {\n                    player.status = 'revealing';\n                }\n            });\n\n            return {\n                gameOver: true,\n                revealPhase: true, // Add a reveal phase flag\n                players: updatedPlayers,\n                winner: winnerIndex,\n                winnerMessage: winMessage,\n                message: [currentAction].filter(Boolean) // Only include the current action\n            };\n        }\n\n        return { gameOver: false };\n    };\n\n    // Update the bot decision-making logic in the useEffect\n\n    useEffect(() => {\n        if (gameState.phase !== 'playing') return;\n\n        const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n        if (!currentPlayer || currentPlayer.isHuman || currentPlayer.status !== 'active') return;\n\n        const botTurn = setTimeout(() => {\n            // Get visible cards of other players (excluding first cards of bots)\n            const otherPlayersVisibleCards = gameState.players.map((player, index) => {\n                if (index === gameState.currentPlayerIndex) return [];\n                return player.visibleCards;\n            }).filter(cards => cards.length > 0);\n\n            // Force bot to draw at least one card after their initial hidden card\n            // A player should have at least 2 cards total (1 hidden + 1 visible)\n            const mustDrawFirstCard = currentPlayer.cards.length <= 1;\n\n            // Decide whether to draw or hold\n            if (mustDrawFirstCard || currentPlayer.total < 11 ||\n                cardUtils.shouldBotDraw(currentPlayer.cards, otherPlayersVisibleCards)) {\n                handleDrawCard();\n            } else {\n                // Bot decides to hold\n                const updatedPlayers = [...gameState.players];\n                updatedPlayers[gameState.currentPlayerIndex].status = 'holding';\n\n                // Find next active player\n                let nextPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;\n                while (\n                    nextPlayerIndex !== gameState.currentPlayerIndex &&\n                    (updatedPlayers[nextPlayerIndex].status === 'eliminated' ||\n                        updatedPlayers[nextPlayerIndex].status === 'holding')\n                ) {\n                    nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;\n                }\n\n                // Check if all players are holding or eliminated\n                const allDone = updatedPlayers.every(p => p.status !== 'active');\n\n                if (allDone) {\n                    // Check if game should end using the shared game end logic\n                    const gameEndCheck = checkGameEnd(updatedPlayers,\n                        `${currentPlayer.name} decided to hold with a total of ${currentPlayer.total}.`);\n\n                    if (gameEndCheck.gameOver) {\n                        setGameState({\n                            ...gameState,\n                            players: gameEndCheck.players,\n                            deck: gameState.deck,\n                            phase: 'revealing',\n                            revealPhase: true,\n                            pendingWinner: gameEndCheck.winner,\n                            pendingWinnerMessage: gameEndCheck.winnerMessage,\n                            gameLog: [...gameState.gameLog, ...gameEndCheck.message]\n                        });\n                        return;\n                    }\n                }\n\n                setGameState({\n                    ...gameState,\n                    players: updatedPlayers,\n                    currentPlayerIndex: nextPlayerIndex,\n                    gameLog: [...gameState.gameLog,\n                    `${currentPlayer.name} decided to hold with a total of ${currentPlayer.total}.`,\n                    `${updatedPlayers[nextPlayerIndex].name}'s turn.`\n                    ]\n                });\n            }\n        }, 1000); // 1 second delay for bot actions\n\n        return () => clearTimeout(botTurn);\n    }, [gameState]);\n\n\n\n    // Add this useEffect to handle the reveal phase\n    useEffect(() => {\n        // Only run this effect when we're in the revealing phase\n        if (gameState.phase === 'revealing' && gameState.revealPhase) {\n            const revealTimer = setTimeout(() => {\n                const updatedPlayers = [...gameState.players];\n\n                // After revealing, set the winner status\n                if (gameState.pendingWinner !== -1) {\n                    updatedPlayers[gameState.pendingWinner].status = 'winner';\n                }\n\n                setGameState({\n                    ...gameState,\n                    players: updatedPlayers,\n                    phase: 'gameOver',\n                    revealPhase: false,\n                    winner: gameState.pendingWinner,\n                    gameLog: [...gameState.gameLog, gameState.pendingWinnerMessage]\n                });\n            }, 500); // 2 second delay to allow players to see all cards\n\n            return () => clearTimeout(revealTimer);\n        }\n    }, [gameState.phase, gameState.revealPhase]);\n\n    // Use this function to reset the game and ensure all textures are reloaded\n    const resetGame = () => {\n        // Reset the game with the same number of players\n        const numPlayers = gameState.players.length;\n\n        // Clear any cached textures\n        THREE.Cache.clear();\n\n        // Force a slight delay to ensure cleanup happens\n        setTimeout(() => {\n            setupGame(numPlayers);\n        }, 50);\n    };\n\n    const returnToHome = () => {\n        // Reset everything and return to setup phase\n        setGameState({\n            phase: 'setup',\n            players: [],\n            deck: [],\n            currentPlayerIndex: 0,\n            winner: null,\n            gameLog: []\n        });\n    };\n    // In your return statement, pass the gameId to GameBoard:\n    return (\n        <div className=\"game-container\">\n            {gameState.phase === 'setup' ? (\n                <GameSetup onSetupComplete={setupGame} />\n            ) : (\n                <GameBoard\n                    gameState={gameState}\n                    onDrawCard={handleDrawCard}\n                    onHold={handleHold}\n                    onReset={resetGame}\n                    onReturnHome={returnToHome}\n                />\n            )}\n        </div>\n    );\n}"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AAClD,SAASC,SAAS,QAAQ,oBAAoB;AAC9C,OAAOC,SAAS,MAAM,aAAa;AACnC,OAAOC,SAAS,MAAM,aAAa;AACnC,SAASC,cAAc,QAAQ,wBAAwB;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAExD,eAAe,SAASC,IAAIA,CAAA,EAAG;EAAAC,EAAA;EAC3B,MAAM,CAACC,SAAS,EAAEC,YAAY,CAAC,GAAGX,QAAQ,CAAC;IACvCY,KAAK,EAAE,OAAO;IACdC,OAAO,EAAE,EAAE;IACXC,IAAI,EAAE,EAAE;IACRC,kBAAkB,EAAE,CAAC;IACrBC,MAAM,EAAE,IAAI;IACZC,OAAO,EAAE,EAAE;IACXC,MAAM,EAAEC,IAAI,CAACC,GAAG,CAAC;EACrB,CAAC,CAAC;;EAEN;EACInB,SAAS,CAAC,MAAM;IACZ;IACA,MAAMoB,SAAS,GAAG,EAAE;IACpBnB,SAAS,CAACoB,KAAK,CAACC,OAAO,CAACC,IAAI,IAAI;MAC5BtB,SAAS,CAACuB,MAAM,CAACF,OAAO,CAACG,KAAK,IAAI;QAC9BL,SAAS,CAACM,IAAI,CAAC,uBAAuBH,IAAI,IAAIE,KAAK,MAAM,CAAC;MAC9D,CAAC,CAAC;IACN,CAAC,CAAC;;IAEF;IACAL,SAAS,CAACM,IAAI,CAAC,kCAAkC,CAAC;;IAElD;IACAtB,cAAc,CAACuB,eAAe,CAACP,SAAS,CAAC;;IAEzC;IACA,OAAO,MAAM;MACThB,cAAc,CAACwB,UAAU,CAAC,CAAC;IAC/B,CAAC;EACL,CAAC,EAAE,EAAE,CAAC;EACN;EACA,MAAMC,SAAS,GAAIC,UAAU,IAAK;IAC9B,IAAIjB,IAAI,GAAGZ,SAAS,CAAC8B,OAAO,CAAC9B,SAAS,CAAC+B,YAAY,CAAC,CAAC,CAAC;IACtD,MAAMpB,OAAO,GAAG,EAAE;IAClB,MAAMqB,UAAU,GAAG,CAAC,eAAe,CAAC;;IAEpC;IACA,MAAMC,YAAY,GAAG,CAAC,CAAC;;IAEvB;IACA,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGL,UAAU,EAAEK,CAAC,EAAE,EAAE;MACjC,MAAMC,UAAU,GAAGD,CAAC,KAAK,CAAC,GAAG,KAAK,GAAG,OAAOA,CAAC,EAAE;MAC/C,MAAM;QAAEE,KAAK;QAAEC;MAAU,CAAC,GAAGrC,SAAS,CAACsC,SAAS,CAAC1B,IAAI,EAAE,CAAC,CAAC;MACzD,MAAM2B,SAAS,GAAGH,KAAK,CAAC,CAAC,CAAC;MAC1BxB,IAAI,GAAGyB,SAAS,CAAC,CAAC;;MAElB;MACA,MAAMG,MAAM,GAAG;QACXC,EAAE,EAAEP,CAAC;QACLQ,IAAI,EAAEP,UAAU;QAChBQ,OAAO,EAAET,CAAC,KAAK,CAAC;QAChBU,KAAK,EAAE,CAAC,GAAGR,KAAK,CAAC;QACjBS,WAAW,EAAEX,CAAC,KAAK,CAAC,GAAG,EAAE,GAAG,CAAC,GAAGE,KAAK,CAAC;QAAE;QACxCU,YAAY,EAAEZ,CAAC,KAAK,CAAC,GAAG,CAAC,GAAGE,KAAK,CAAC,GAAG,EAAE;QAAE;QACzCW,KAAK,EAAE/C,SAAS,CAACgD,cAAc,CAACZ,KAAK,CAAC;QACtCa,MAAM,EAAE,QAAQ,CAAC;MACrB,CAAC;MAEDtC,OAAO,CAACc,IAAI,CAACe,MAAM,CAAC;;MAEpB;MACA,IAAIN,CAAC,KAAK,CAAC,EAAE;QACTF,UAAU,CAACP,IAAI,CAAC,YAAYzB,SAAS,CAACkD,WAAW,CAACX,SAAS,CAAC,YAAYC,MAAM,CAACO,KAAK,EAAE,CAAC;MAC3F,CAAC,MAAM;QACHf,UAAU,CAACP,IAAI,CAAC,GAAGU,UAAU,eAAe,CAAC;MACjD;IACJ;IAEAH,UAAU,CAACP,IAAI,CAAC,YAAY,CAAC;IAE7BhB,YAAY,CAAC;MACTC,KAAK,EAAE,SAAS;MAChBC,OAAO;MACPC,IAAI;MAAE;MACNC,kBAAkB,EAAE,CAAC;MACrBC,MAAM,EAAE,IAAI;MACZC,OAAO,EAAEiB,UAAU;MACnBhB,MAAM,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC;MAAE;MACpBe;IACJ,CAAC,CAAC;EACN,CAAC;;EAED;EACA;;EAEA,MAAMkB,cAAc,GAAGA,CAAA,KAAM;IACzB,IAAI3C,SAAS,CAACE,KAAK,KAAK,SAAS,EAAE;IAEnC,MAAM0C,aAAa,GAAG5C,SAAS,CAACG,OAAO,CAACH,SAAS,CAACK,kBAAkB,CAAC;IACrE,IAAI,CAACuC,aAAa,IAAIA,aAAa,CAACH,MAAM,KAAK,QAAQ,EAAE;;IAEzD;IACA,MAAM;MAAEb,KAAK;MAAEC;IAAU,CAAC,GAAGrC,SAAS,CAACsC,SAAS,CAAC9B,SAAS,CAACI,IAAI,EAAE,CAAC,CAAC;IACnE,MAAM2B,SAAS,GAAGH,KAAK,CAAC,CAAC,CAAC;;IAE1B;IACA,MAAMiB,cAAc,GAAG,CAAC,GAAG7C,SAAS,CAACG,OAAO,CAAC;IAC7C,MAAM6B,MAAM,GAAGa,cAAc,CAAC7C,SAAS,CAACK,kBAAkB,CAAC;IAE3D2B,MAAM,CAACI,KAAK,GAAG,CAAC,GAAGJ,MAAM,CAACI,KAAK,EAAEL,SAAS,CAAC;IAC3CC,MAAM,CAACM,YAAY,GAAG,CAAC,GAAGN,MAAM,CAACM,YAAY,EAAEP,SAAS,CAAC;IACzDC,MAAM,CAACO,KAAK,GAAG/C,SAAS,CAACgD,cAAc,CAACR,MAAM,CAACI,KAAK,CAAC;;IAErD;IACA,MAAMU,SAAS,GAAG,GAAGd,MAAM,CAACE,IAAI,SAASH,SAAS,CAACf,KAAK,OAAOe,SAAS,CAACjB,IAAI,YAAYkB,MAAM,CAACO,KAAK,EAAE;;IAEvG;IACA,IAAIP,MAAM,CAACO,KAAK,KAAK,EAAE,EAAE;MACrBP,MAAM,CAACS,MAAM,GAAG,QAAQ;MAExBxC,YAAY,CAAC;QACT,GAAGD,SAAS;QACZG,OAAO,EAAE0C,cAAc;QACvBzC,IAAI,EAAEyB,SAAS;QACf3B,KAAK,EAAE,UAAU;QACjBI,MAAM,EAAEN,SAAS,CAACK,kBAAkB;QACpCE,OAAO,EAAE,CAAC,GAAGP,SAAS,CAACO,OAAO,EAAEuC,SAAS,EAAE,GAAGd,MAAM,CAACE,IAAI,uBAAuB;MACpF,CAAC,CAAC;MACF;IACJ;;IAEA;IACA,IAAIF,MAAM,CAACO,KAAK,GAAG,EAAE,EAAE;MACnBP,MAAM,CAACS,MAAM,GAAG,YAAY;;MAE5B;MACA,MAAMM,YAAY,GAAGC,YAAY,CAACH,cAAc,EAC5C,GAAGb,MAAM,CAACE,IAAI,iCAAiC,CAAC;MAEpD,IAAIa,YAAY,CAACE,QAAQ,EAAE;QACvBhD,YAAY,CAAC;UACT,GAAGD,SAAS;UACZG,OAAO,EAAE4C,YAAY,CAAC5C,OAAO;UAC7BC,IAAI,EAAEyB,SAAS;UACf3B,KAAK,EAAE,WAAW;UAAE;UACpBgD,WAAW,EAAE,IAAI;UACjBC,aAAa,EAAEJ,YAAY,CAACzC,MAAM;UAAE;UACpC8C,oBAAoB,EAAEL,YAAY,CAACM,aAAa;UAChD9C,OAAO,EAAE,CAAC,GAAGP,SAAS,CAACO,OAAO,EAAEuC,SAAS,EAAE,GAAGC,YAAY,CAACO,OAAO;QACtE,CAAC,CAAC;QACF;MACJ;;MAEA;MACA,IAAIC,eAAe,GAAG,CAACvD,SAAS,CAACK,kBAAkB,GAAG,CAAC,IAAIL,SAAS,CAACG,OAAO,CAACqD,MAAM;MACnF,OACID,eAAe,KAAKvD,SAAS,CAACK,kBAAkB,KAC/CwC,cAAc,CAACU,eAAe,CAAC,CAACd,MAAM,KAAK,YAAY,IACpDI,cAAc,CAACU,eAAe,CAAC,CAACd,MAAM,KAAK,SAAS,CAAC,EAC3D;QACEc,eAAe,GAAG,CAACA,eAAe,GAAG,CAAC,IAAIvD,SAAS,CAACG,OAAO,CAACqD,MAAM;MACtE;MAEAvD,YAAY,CAAC;QACT,GAAGD,SAAS;QACZG,OAAO,EAAE0C,cAAc;QACvBzC,IAAI,EAAEyB,SAAS;QACfxB,kBAAkB,EAAEkD,eAAe;QACnChD,OAAO,EAAE,CAAC,GAAGP,SAAS,CAACO,OAAO,EAAEuC,SAAS,EACzC,GAAGd,MAAM,CAACE,IAAI,iCAAiC,EAC/C,GAAGW,cAAc,CAACU,eAAe,CAAC,CAACrB,IAAI,UAAU;MACrD,CAAC,CAAC;MACF;IACJ;;IAEA;IACA,MAAMuB,YAAY,GAAGzB,MAAM,CAACO,KAAK,GAAG,EAAE;IAEtC,IAAIkB,YAAY,EAAE;MACd;MACAxD,YAAY,CAAC;QACT,GAAGD,SAAS;QACZG,OAAO,EAAE0C,cAAc;QACvBzC,IAAI,EAAEyB,SAAS;QACftB,OAAO,EAAE,CAAC,GAAGP,SAAS,CAACO,OAAO,EAAEuC,SAAS;MAC7C,CAAC,CAAC;IACN,CAAC,MAAM,IAAId,MAAM,CAACG,OAAO,EAAE;MACvB;MACAlC,YAAY,CAAC;QACT,GAAGD,SAAS;QACZG,OAAO,EAAE0C,cAAc;QACvBzC,IAAI,EAAEyB,SAAS;QACftB,OAAO,EAAE,CAAC,GAAGP,SAAS,CAACO,OAAO,EAAEuC,SAAS;MAC7C,CAAC,CAAC;IACN,CAAC,MAAM;MACH;MACA7C,YAAY,CAAC;QACT,GAAGD,SAAS;QACZG,OAAO,EAAE0C,cAAc;QACvBzC,IAAI,EAAEyB,SAAS;QACftB,OAAO,EAAE,CAAC,GAAGP,SAAS,CAACO,OAAO,EAAEuC,SAAS;MAC7C,CAAC,CAAC;IACN;EACJ,CAAC;;EAED;EACA,MAAMY,UAAU,GAAGA,CAAA,KAAM;IACrB,IAAI1D,SAAS,CAACE,KAAK,KAAK,SAAS,EAAE;IAEnC,MAAM0C,aAAa,GAAG5C,SAAS,CAACG,OAAO,CAACH,SAAS,CAACK,kBAAkB,CAAC;IACrE,IAAI,CAACuC,aAAa,IAAI,CAACA,aAAa,CAACT,OAAO,IAAIS,aAAa,CAACH,MAAM,KAAK,QAAQ,EAAE;;IAEnF;IACA,IAAIG,aAAa,CAACL,KAAK,GAAG,EAAE,EAAE;MAC1BtC,YAAY,CAAC;QACT,GAAGD,SAAS;QACZO,OAAO,EAAE,CAAC,GAAGP,SAAS,CAACO,OAAO,EAAE,4CAA4C;MAChF,CAAC,CAAC;MACF;IACJ;IAEA,MAAMsC,cAAc,GAAG,CAAC,GAAG7C,SAAS,CAACG,OAAO,CAAC;IAC7C0C,cAAc,CAAC7C,SAAS,CAACK,kBAAkB,CAAC,CAACoC,MAAM,GAAG,SAAS;;IAE/D;IACA,IAAIc,eAAe,GAAG,CAACvD,SAAS,CAACK,kBAAkB,GAAG,CAAC,IAAIL,SAAS,CAACG,OAAO,CAACqD,MAAM;IACnF,OACID,eAAe,KAAKvD,SAAS,CAACK,kBAAkB,KAC/CwC,cAAc,CAACU,eAAe,CAAC,CAACd,MAAM,KAAK,YAAY,IACpDI,cAAc,CAACU,eAAe,CAAC,CAACd,MAAM,KAAK,SAAS,CAAC,EAC3D;MACEc,eAAe,GAAG,CAACA,eAAe,GAAG,CAAC,IAAIvD,SAAS,CAACG,OAAO,CAACqD,MAAM;IACtE;;IAEA;IACA,MAAMG,OAAO,GAAGd,cAAc,CAACe,KAAK,CAACC,CAAC,IAAIA,CAAC,CAACpB,MAAM,KAAK,QAAQ,CAAC;IAEhE,IAAIkB,OAAO,EAAE;MACT;MACA,IAAIG,QAAQ,GAAG,CAAC;MAChB,IAAIC,WAAW,GAAG,CAAC,CAAC;MAEpBlB,cAAc,CAAChC,OAAO,CAAC,CAACgD,CAAC,EAAEG,GAAG,KAAK;QAC/B,IAAIH,CAAC,CAACpB,MAAM,KAAK,YAAY,IAAIoB,CAAC,CAACtB,KAAK,IAAI,EAAE,IAAIsB,CAAC,CAACtB,KAAK,GAAGuB,QAAQ,EAAE;UAClEA,QAAQ,GAAGD,CAAC,CAACtB,KAAK;UAClBwB,WAAW,GAAGC,GAAG;QACrB;MACJ,CAAC,CAAC;MAEF,IAAID,WAAW,KAAK,CAAC,CAAC,EAAE;QACpBlB,cAAc,CAACkB,WAAW,CAAC,CAACtB,MAAM,GAAG,QAAQ;QAE7CxC,YAAY,CAAC;UACT,GAAGD,SAAS;UACZG,OAAO,EAAE0C,cAAc;UACvB3C,KAAK,EAAE,UAAU;UACjBI,MAAM,EAAEyD,WAAW;UACnBxD,OAAO,EAAE,CAAC,GAAGP,SAAS,CAACO,OAAO,EAC9B,uCAAuCqC,aAAa,CAACL,KAAK,GAAG,EAC7D,GAAGM,cAAc,CAACkB,WAAW,CAAC,CAAC7B,IAAI,yBAAyB4B,QAAQ,GAAG;QAE3E,CAAC,CAAC;QACF;MACJ;IACJ;IAEA7D,YAAY,CAAC;MACT,GAAGD,SAAS;MACZG,OAAO,EAAE0C,cAAc;MACvBxC,kBAAkB,EAAEkD,eAAe;MACnChD,OAAO,EAAE,CAAC,GAAGP,SAAS,CAACO,OAAO,EAC9B,uCAAuCqC,aAAa,CAACL,KAAK,GAAG,EAC7D,GAAGM,cAAc,CAACU,eAAe,CAAC,CAACrB,IAAI,UAAU;IAErD,CAAC,CAAC;EACN,CAAC;;EAGD;EACA,MAAM+B,eAAe,GAAI9D,OAAO,IAAK;IACjC;IACA,MAAM+D,WAAW,GAAG/D,OAAO,CAACgE,SAAS,CAACN,CAAC,IAAIA,CAAC,CAACtB,KAAK,KAAK,EAAE,CAAC;IAC1D,IAAI2B,WAAW,KAAK,CAAC,CAAC,EAAE;MACpB,OAAO;QACHH,WAAW,EAAEG,WAAW;QACxBE,UAAU,EAAE,GAAGjE,OAAO,CAAC+D,WAAW,CAAC,CAAChC,IAAI;MAC5C,CAAC;IACL;;IAEA;IACA,MAAMmC,aAAa,GAAGlE,OAAO,CAACyD,KAAK,CAACC,CAAC,IAAIA,CAAC,CAACpB,MAAM,KAAK,YAAY,CAAC;IACnE,IAAI4B,aAAa,EAAE;MACf,OAAO;QACHN,WAAW,EAAE,CAAC,CAAC;QACfK,UAAU,EAAE;MAChB,CAAC;IACL;;IAEA;IACA,IAAIN,QAAQ,GAAG,CAAC;IAChB,IAAIC,WAAW,GAAG,CAAC,CAAC;IAEpB5D,OAAO,CAACU,OAAO,CAAC,CAACmB,MAAM,EAAEgC,GAAG,KAAK;MAC7B,IAAIhC,MAAM,CAACS,MAAM,KAAK,YAAY,IAAIT,MAAM,CAACO,KAAK,IAAI,EAAE,IAAIP,MAAM,CAACO,KAAK,GAAGuB,QAAQ,EAAE;QACjFA,QAAQ,GAAG9B,MAAM,CAACO,KAAK;QACvBwB,WAAW,GAAGC,GAAG;MACrB;IACJ,CAAC,CAAC;IAEF,IAAID,WAAW,KAAK,CAAC,CAAC,EAAE;MACpB,OAAO;QACHA,WAAW;QACXK,UAAU,EAAE,GAAGjE,OAAO,CAAC4D,WAAW,CAAC,CAAC7B,IAAI,yBAAyB4B,QAAQ;MAC7E,CAAC;IACL;;IAEA;IACA,OAAO;MACHC,WAAW,EAAE,CAAC,CAAC;MACfK,UAAU,EAAE;IAChB,CAAC;EACL,CAAC;;EAED;EACA;EACA,MAAMpB,YAAY,GAAGA,CAACH,cAAc,EAAEyB,aAAa,GAAG,EAAE,KAAK;IACzD;IACA,MAAMX,OAAO,GAAGd,cAAc,CAACe,KAAK,CAACC,CAAC,IAAIA,CAAC,CAACpB,MAAM,KAAK,QAAQ,CAAC;IAEhE,IAAIkB,OAAO,EAAE;MACT;MACA,MAAM;QAAEI,WAAW;QAAEK;MAAW,CAAC,GAAGH,eAAe,CAACpB,cAAc,CAAC;;MAEnE;MACAA,cAAc,CAAChC,OAAO,CAACmB,MAAM,IAAI;QAC7B,IAAIA,MAAM,CAACS,MAAM,KAAK,YAAY,EAAE;UAChCT,MAAM,CAACS,MAAM,GAAG,WAAW;QAC/B;MACJ,CAAC,CAAC;MAEF,OAAO;QACHQ,QAAQ,EAAE,IAAI;QACdC,WAAW,EAAE,IAAI;QAAE;QACnB/C,OAAO,EAAE0C,cAAc;QACvBvC,MAAM,EAAEyD,WAAW;QACnBV,aAAa,EAAEe,UAAU;QACzBd,OAAO,EAAE,CAACgB,aAAa,CAAC,CAACC,MAAM,CAACC,OAAO,CAAC,CAAC;MAC7C,CAAC;IACL;IAEA,OAAO;MAAEvB,QAAQ,EAAE;IAAM,CAAC;EAC9B,CAAC;;EAED;;EAEA1D,SAAS,CAAC,MAAM;IACZ,IAAIS,SAAS,CAACE,KAAK,KAAK,SAAS,EAAE;IAEnC,MAAM0C,aAAa,GAAG5C,SAAS,CAACG,OAAO,CAACH,SAAS,CAACK,kBAAkB,CAAC;IACrE,IAAI,CAACuC,aAAa,IAAIA,aAAa,CAACT,OAAO,IAAIS,aAAa,CAACH,MAAM,KAAK,QAAQ,EAAE;IAElF,MAAMgC,OAAO,GAAGC,UAAU,CAAC,MAAM;MAC7B;MACA,MAAMC,wBAAwB,GAAG3E,SAAS,CAACG,OAAO,CAACyE,GAAG,CAAC,CAAC5C,MAAM,EAAE6C,KAAK,KAAK;QACtE,IAAIA,KAAK,KAAK7E,SAAS,CAACK,kBAAkB,EAAE,OAAO,EAAE;QACrD,OAAO2B,MAAM,CAACM,YAAY;MAC9B,CAAC,CAAC,CAACiC,MAAM,CAACnC,KAAK,IAAIA,KAAK,CAACoB,MAAM,GAAG,CAAC,CAAC;;MAEpC;MACA;MACA,MAAMsB,iBAAiB,GAAGlC,aAAa,CAACR,KAAK,CAACoB,MAAM,IAAI,CAAC;;MAEzD;MACA,IAAIsB,iBAAiB,IAAIlC,aAAa,CAACL,KAAK,GAAG,EAAE,IAC7C/C,SAAS,CAACuF,aAAa,CAACnC,aAAa,CAACR,KAAK,EAAEuC,wBAAwB,CAAC,EAAE;QACxEhC,cAAc,CAAC,CAAC;MACpB,CAAC,MAAM;QACH;QACA,MAAME,cAAc,GAAG,CAAC,GAAG7C,SAAS,CAACG,OAAO,CAAC;QAC7C0C,cAAc,CAAC7C,SAAS,CAACK,kBAAkB,CAAC,CAACoC,MAAM,GAAG,SAAS;;QAE/D;QACA,IAAIc,eAAe,GAAG,CAACvD,SAAS,CAACK,kBAAkB,GAAG,CAAC,IAAIL,SAAS,CAACG,OAAO,CAACqD,MAAM;QACnF,OACID,eAAe,KAAKvD,SAAS,CAACK,kBAAkB,KAC/CwC,cAAc,CAACU,eAAe,CAAC,CAACd,MAAM,KAAK,YAAY,IACpDI,cAAc,CAACU,eAAe,CAAC,CAACd,MAAM,KAAK,SAAS,CAAC,EAC3D;UACEc,eAAe,GAAG,CAACA,eAAe,GAAG,CAAC,IAAIvD,SAAS,CAACG,OAAO,CAACqD,MAAM;QACtE;;QAEA;QACA,MAAMG,OAAO,GAAGd,cAAc,CAACe,KAAK,CAACC,CAAC,IAAIA,CAAC,CAACpB,MAAM,KAAK,QAAQ,CAAC;QAEhE,IAAIkB,OAAO,EAAE;UACT;UACA,MAAMZ,YAAY,GAAGC,YAAY,CAACH,cAAc,EAC5C,GAAGD,aAAa,CAACV,IAAI,oCAAoCU,aAAa,CAACL,KAAK,GAAG,CAAC;UAEpF,IAAIQ,YAAY,CAACE,QAAQ,EAAE;YACvBhD,YAAY,CAAC;cACT,GAAGD,SAAS;cACZG,OAAO,EAAE4C,YAAY,CAAC5C,OAAO;cAC7BC,IAAI,EAAEJ,SAAS,CAACI,IAAI;cACpBF,KAAK,EAAE,WAAW;cAClBgD,WAAW,EAAE,IAAI;cACjBC,aAAa,EAAEJ,YAAY,CAACzC,MAAM;cAClC8C,oBAAoB,EAAEL,YAAY,CAACM,aAAa;cAChD9C,OAAO,EAAE,CAAC,GAAGP,SAAS,CAACO,OAAO,EAAE,GAAGwC,YAAY,CAACO,OAAO;YAC3D,CAAC,CAAC;YACF;UACJ;QACJ;QAEArD,YAAY,CAAC;UACT,GAAGD,SAAS;UACZG,OAAO,EAAE0C,cAAc;UACvBxC,kBAAkB,EAAEkD,eAAe;UACnChD,OAAO,EAAE,CAAC,GAAGP,SAAS,CAACO,OAAO,EAC9B,GAAGqC,aAAa,CAACV,IAAI,oCAAoCU,aAAa,CAACL,KAAK,GAAG,EAC/E,GAAGM,cAAc,CAACU,eAAe,CAAC,CAACrB,IAAI,UAAU;QAErD,CAAC,CAAC;MACN;IACJ,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;;IAEV,OAAO,MAAM8C,YAAY,CAACP,OAAO,CAAC;EACtC,CAAC,EAAE,CAACzE,SAAS,CAAC,CAAC;;EAIf;EACAT,SAAS,CAAC,MAAM;IACZ;IACA,IAAIS,SAAS,CAACE,KAAK,KAAK,WAAW,IAAIF,SAAS,CAACkD,WAAW,EAAE;MAC1D,MAAM+B,WAAW,GAAGP,UAAU,CAAC,MAAM;QACjC,MAAM7B,cAAc,GAAG,CAAC,GAAG7C,SAAS,CAACG,OAAO,CAAC;;QAE7C;QACA,IAAIH,SAAS,CAACmD,aAAa,KAAK,CAAC,CAAC,EAAE;UAChCN,cAAc,CAAC7C,SAAS,CAACmD,aAAa,CAAC,CAACV,MAAM,GAAG,QAAQ;QAC7D;QAEAxC,YAAY,CAAC;UACT,GAAGD,SAAS;UACZG,OAAO,EAAE0C,cAAc;UACvB3C,KAAK,EAAE,UAAU;UACjBgD,WAAW,EAAE,KAAK;UAClB5C,MAAM,EAAEN,SAAS,CAACmD,aAAa;UAC/B5C,OAAO,EAAE,CAAC,GAAGP,SAAS,CAACO,OAAO,EAAEP,SAAS,CAACoD,oBAAoB;QAClE,CAAC,CAAC;MACN,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC;;MAET,OAAO,MAAM4B,YAAY,CAACC,WAAW,CAAC;IAC1C;EACJ,CAAC,EAAE,CAACjF,SAAS,CAACE,KAAK,EAAEF,SAAS,CAACkD,WAAW,CAAC,CAAC;;EAE5C;EACA,MAAMgC,SAAS,GAAGA,CAAA,KAAM;IACpB;IACA,MAAM7D,UAAU,GAAGrB,SAAS,CAACG,OAAO,CAACqD,MAAM;;IAE3C;IACA2B,KAAK,CAACC,KAAK,CAACC,KAAK,CAAC,CAAC;;IAEnB;IACAX,UAAU,CAAC,MAAM;MACbtD,SAAS,CAACC,UAAU,CAAC;IACzB,CAAC,EAAE,EAAE,CAAC;EACV,CAAC;EAED,MAAMiE,YAAY,GAAGA,CAAA,KAAM;IACvB;IACArF,YAAY,CAAC;MACTC,KAAK,EAAE,OAAO;MACdC,OAAO,EAAE,EAAE;MACXC,IAAI,EAAE,EAAE;MACRC,kBAAkB,EAAE,CAAC;MACrBC,MAAM,EAAE,IAAI;MACZC,OAAO,EAAE;IACb,CAAC,CAAC;EACN,CAAC;EACD;EACA,oBACIV,OAAA;IAAK0F,SAAS,EAAC,gBAAgB;IAAAC,QAAA,EAC1BxF,SAAS,CAACE,KAAK,KAAK,OAAO,gBACxBL,OAAA,CAACJ,SAAS;MAACgG,eAAe,EAAErE;IAAU;MAAAsE,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAE,CAAC,gBAEzChG,OAAA,CAACH,SAAS;MACNM,SAAS,EAAEA,SAAU;MACrB8F,UAAU,EAAEnD,cAAe;MAC3BoD,MAAM,EAAErC,UAAW;MACnBsC,OAAO,EAAEd,SAAU;MACnBe,YAAY,EAAEX;IAAa;MAAAI,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAC9B;EACJ;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACA,CAAC;AAEd;AAAC9F,EAAA,CA1euBD,IAAI;AAAAoG,EAAA,GAAJpG,IAAI;AAAA,IAAAoG,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}