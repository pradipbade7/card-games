{"ast":null,"code":"import { cardUtils } from '../../services/cardUtils'; // Update path\n\n// Initialize game with specified number of players\nexport function setupInitialGame(numPlayers, cardBackStyle = 'cardback') {\n  let deck = cardUtils.shuffle(cardUtils.generateDeck());\n  const players = [];\n  const initialLog = ['Game started!'];\n\n  // Randomly determine the first player (0 to numPlayers-1)\n  const firstPlayerIndex = Math.floor(Math.random() * numPlayers);\n\n  // Create all players\n  for (let i = 0; i < numPlayers; i++) {\n    const playerName = i === 0 ? 'You' : `Bot ${i}`;\n    const {\n      drawn,\n      remaining\n    } = cardUtils.drawCards(deck, 1);\n    const drawnCard = drawn[0];\n    deck = remaining;\n    const player = {\n      id: i,\n      name: playerName,\n      isHuman: i === 0,\n      cards: [...drawn],\n      hiddenCards: i === 0 ? [] : [...drawn],\n      visibleCards: i === 0 ? [...drawn] : [],\n      total: cardUtils.calculateTotal(drawn),\n      status: 'active' // active, holding, eliminated, winner\n    };\n    players.push(player);\n    if (i === 0) {\n      initialLog.push(`You drew ${cardUtils.getCardName(drawnCard)}. Total: ${player.total}`);\n    } else {\n      initialLog.push(`${playerName} drew a card.`);\n    }\n  }\n\n  // Log who goes first\n  const firstPlayerName = players[firstPlayerIndex].isHuman ? 'You' : players[firstPlayerIndex].name;\n  initialLog.push(`${firstPlayerName} will go first.`);\n  return {\n    phase: 'playing',\n    players,\n    deck,\n    currentPlayerIndex: firstPlayerIndex,\n    winner: null,\n    gameLog: initialLog,\n    gameId: Date.now(),\n    cardBackStyle: cardBackStyle\n  };\n}\n\n// Handle drawing a card\n// export function handleDrawCard(gameState, currentPlayer, playerIndex) {\n//     // Draw a card from the deck\n//     const { drawn, remaining } = cardUtils.drawCards(gameState.deck, 1);\n//     const drawnCard = drawn[0];\n\n//     // Update player's cards and total\n//     const updatedPlayers = [...gameState.players];\n//     const player = updatedPlayers[playerIndex];\n\n//     player.cards = [...player.cards, drawnCard];\n//     player.visibleCards = [...player.visibleCards, drawnCard];\n//     player.total = cardUtils.calculateTotal(player.cards);\n\n//     // Log the action\n//     const actionLog = `${player.name} drew ${cardUtils.getCardName(drawnCard)}. Total: ${player.total}`;\n\n//     // Check if player reached exactly 17\n//     if (player.total === 17) {\n//         player.status = 'winner';\n//         return {\n//             ...gameState,\n//             players: updatedPlayers,\n//             deck: remaining,\n//             phase: 'gameOver',\n//             winner: playerIndex,\n//             gameLog: [...gameState.gameLog, actionLog, `${player.name} won with exactly 17!`]\n//         };\n//     }\n\n//     // Check if player exceeded 17\n//     if (player.total > 17) {\n//         player.status = 'eliminated';\n\n//         // Check if all players are eliminated or if the game is over\n//         const gameEndCheck = checkGameEnd(\n//             updatedPlayers,\n//             `${player.name} exceeded 17 and is eliminated!`\n//         );\n\n//         if (gameEndCheck.gameOver) {\n//             return {\n//                 ...gameState,\n//                 players: gameEndCheck.players,\n//                 deck: remaining,\n//                 phase: 'revealing',\n//                 revealPhase: true,\n//                 pendingWinner: gameEndCheck.winner,\n//                 pendingWinnerMessage: gameEndCheck.winnerMessage,\n//                 gameLog: [...gameState.gameLog, actionLog, ...gameEndCheck.message]\n//             };\n//         }\n\n//         // Find next active player\n//         let nextPlayerIndex = (playerIndex + 1) % gameState.players.length;\n//         while (\n//             nextPlayerIndex !== playerIndex &&\n//             (updatedPlayers[nextPlayerIndex].status === 'eliminated' ||\n//                 updatedPlayers[nextPlayerIndex].status === 'holding')\n//         ) {\n//             nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;\n//         }\n\n//         return {\n//             ...gameState,\n//             players: updatedPlayers,\n//             deck: remaining,\n//             currentPlayerIndex: nextPlayerIndex,\n//             gameLog: [\n//                 ...gameState.gameLog, \n//                 actionLog,\n//                 `${player.name} exceeded 17 and is eliminated!`,\n//                 `${updatedPlayers[nextPlayerIndex].name}'s turn.`\n//             ]\n//         };\n//     }\n\n//     // Standard case - continue game\n//     return {\n//         ...gameState,\n//         players: updatedPlayers,\n//         deck: remaining,\n//         gameLog: [...gameState.gameLog, actionLog]\n//     };\n// }\n\nexport function handleDrawCard(gameState, player, playerIndex) {\n  // Draw card\n  const {\n    drawn,\n    remaining\n  } = cardUtils.drawCards(gameState.deck, 1);\n  const drawnCard = drawn[0];\n  const newTotal = player.total + cardUtils.getCardValue(drawnCard);\n\n  // Update player cards\n  const updatedPlayers = [...gameState.players];\n  const updatedPlayer = {\n    ...player,\n    cards: [...player.cards, drawnCard],\n    visibleCards: [...player.visibleCards, drawnCard],\n    total: newTotal\n  };\n\n  // Create log message\n  let actionLog = `${player.name} drew ${cardUtils.getCardName(drawnCard)}. Total: ${newTotal}`;\n\n  // Check if player is eliminated (bust)\n  if (newTotal > 17) {\n    updatedPlayer.status = 'eliminated';\n\n    // Find next active player\n    let nextPlayerIndex = (playerIndex + 1) % gameState.players.length;\n    while (nextPlayerIndex !== playerIndex && (updatedPlayers[nextPlayerIndex].status === 'eliminated' || updatedPlayers[nextPlayerIndex].status === 'holding')) {\n      nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;\n    }\n\n    // Check if all players are done\n    const allDone = updatedPlayers.every(p => p.status !== 'active');\n    if (allDone) {\n      const gameEndCheck = checkGameEnd(updatedPlayers, `${player.name} drew ${cardUtils.getCardName(drawnCard)} and was eliminated with a total of ${newTotal}.`);\n      if (gameEndCheck.gameOver) {\n        return {\n          ...gameState,\n          players: gameEndCheck.players,\n          deck: remaining,\n          phase: 'revealing',\n          revealPhase: true,\n          pendingWinner: gameEndCheck.winner,\n          pendingWinnerMessage: gameEndCheck.winnerMessage,\n          gameLog: [...gameState.gameLog, ...gameEndCheck.message]\n        };\n      }\n    }\n    return {\n      ...gameState,\n      players: updatedPlayers,\n      deck: remaining,\n      currentPlayerIndex: nextPlayerIndex,\n      gameLog: [...gameState.gameLog, actionLog, `${player.name} exceeded 17 and is eliminated!`, `${updatedPlayers[nextPlayerIndex].name}'s turn.`]\n    };\n  }\n\n  // Check if player wins by having exactly 17 or 7 cards\n  if (newTotal === 17 || updatedPlayer.cards.length === 7) {\n    updatedPlayer.status = 'winner';\n    return {\n      ...gameState,\n      players: updatedPlayers,\n      deck: remaining,\n      phase: 'gameOver',\n      winner: playerIndex,\n      gameLog: [...gameState.gameLog, actionLog, `${player.name} wins the game!`]\n    };\n  }\n\n  // For human players, stay on their turn unless they get exactly 17 or 7 cards\n  if (player.isHuman) {\n    return {\n      ...gameState,\n      players: updatedPlayers,\n      deck: remaining,\n      gameLog: [...gameState.gameLog, actionLog]\n    };\n  }\n\n  // For AI players, move to next\n  let nextPlayerIndex = (playerIndex + 1) % gameState.players.length;\n  while (nextPlayerIndex !== playerIndex && (updatedPlayers[nextPlayerIndex].status === 'eliminated' || updatedPlayers[nextPlayerIndex].status === 'holding')) {\n    nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;\n  }\n  return {\n    ...gameState,\n    players: updatedPlayers,\n    deck: remaining,\n    currentPlayerIndex: nextPlayerIndex,\n    gameLog: [...gameState.gameLog, actionLog, `${updatedPlayers[nextPlayerIndex].name}'s turn.`]\n  };\n}\n\n// Handle player holding\nexport function handleHold(gameState, currentPlayer, playerIndex) {\n  // Check if player has at least 2 cards (initial card + at least one drawn card)\n  if (currentPlayer.cards.length < 2) {\n    return gameState; // Cannot hold until drawing at least one more card\n  }\n\n  // Check if player has reached at least 11 points\n  if (currentPlayer.total < 11) {\n    return gameState; // Cannot hold below 11\n  }\n  const updatedPlayers = [...gameState.players];\n  updatedPlayers[playerIndex].status = 'holding';\n\n  // Find next active player\n  let nextPlayerIndex = (playerIndex + 1) % gameState.players.length;\n  while (nextPlayerIndex !== playerIndex && (updatedPlayers[nextPlayerIndex].status === 'eliminated' || updatedPlayers[nextPlayerIndex].status === 'holding')) {\n    nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;\n  }\n  const allDone = updatedPlayers.every(p => p.status !== 'active');\n  if (allDone) {\n    const gameEndCheck = checkGameEnd(updatedPlayers, `${currentPlayer.name} decided to hold with a total of ${currentPlayer.total}.`);\n    if (gameEndCheck.gameOver) {\n      return {\n        ...gameState,\n        players: gameEndCheck.players,\n        phase: 'revealing',\n        revealPhase: true,\n        pendingWinner: gameEndCheck.winner,\n        pendingWinnerMessage: gameEndCheck.winnerMessage,\n        gameLog: [...gameState.gameLog, ...gameEndCheck.message]\n      };\n    }\n  }\n  return {\n    ...gameState,\n    players: updatedPlayers,\n    currentPlayerIndex: nextPlayerIndex,\n    gameLog: [...gameState.gameLog, `${currentPlayer.name} decided to hold with a total of ${currentPlayer.total}.`, `${updatedPlayers[nextPlayerIndex].name}'s turn.`]\n  };\n}\n\n// Check if the game has ended\nexport function checkGameEnd(players, currentAction = '') {\n  const allDone = players.every(p => p.status !== 'active');\n  if (allDone) {\n    const {\n      winnerIndex,\n      winMessage\n    } = determineWinner(players);\n    players.forEach(player => {\n      if (player.status !== 'eliminated') {\n        player.status = 'revealing';\n      }\n    });\n    return {\n      gameOver: true,\n      revealPhase: true,\n      players,\n      winner: winnerIndex,\n      winnerMessage: winMessage,\n      message: [currentAction].filter(Boolean)\n    };\n  }\n  return {\n    gameOver: false\n  };\n}\n\n// Determine the winner based on game rules\nexport function determineWinner(players) {\n  const exactWinner = players.findIndex(p => p.total === 17);\n  if (exactWinner !== -1) {\n    return {\n      winnerIndex: exactWinner,\n      winMessage: `${players[exactWinner].name} won with exactly 17!`\n    };\n  }\n  const allEliminated = players.every(p => p.status === 'eliminated');\n  if (allEliminated) {\n    return {\n      winnerIndex: -1,\n      winMessage: 'All players exceeded 17. Game is void.'\n    };\n  }\n  let maxTotal = 0;\n  let winnerIndex = -1;\n  players.forEach((player, idx) => {\n    if (player.status !== 'eliminated' && player.total <= 17 && player.total > maxTotal) {\n      maxTotal = player.total;\n      winnerIndex = idx;\n    }\n  });\n  if (winnerIndex !== -1) {\n    return {\n      winnerIndex,\n      winMessage: `${players[winnerIndex].name} wins with a total of ${maxTotal}!`\n    };\n  }\n  return {\n    winnerIndex: -1,\n    winMessage: 'No winner could be determined.'\n  };\n}","map":{"version":3,"names":["cardUtils","setupInitialGame","numPlayers","cardBackStyle","deck","shuffle","generateDeck","players","initialLog","firstPlayerIndex","Math","floor","random","i","playerName","drawn","remaining","drawCards","drawnCard","player","id","name","isHuman","cards","hiddenCards","visibleCards","total","calculateTotal","status","push","getCardName","firstPlayerName","phase","currentPlayerIndex","winner","gameLog","gameId","Date","now","handleDrawCard","gameState","playerIndex","newTotal","getCardValue","updatedPlayers","updatedPlayer","actionLog","nextPlayerIndex","length","allDone","every","p","gameEndCheck","checkGameEnd","gameOver","revealPhase","pendingWinner","pendingWinnerMessage","winnerMessage","message","handleHold","currentPlayer","currentAction","winnerIndex","winMessage","determineWinner","forEach","filter","Boolean","exactWinner","findIndex","allEliminated","maxTotal","idx"],"sources":["/Users/pradipbade/Documents/Projects/Small Projects/react-3d-card-game/src/games/gameOf17/gameLogic.js"],"sourcesContent":["import { cardUtils } from '../../services/cardUtils'; // Update path\n\n// Initialize game with specified number of players\nexport function setupInitialGame(numPlayers, cardBackStyle = 'cardback') {\n    let deck = cardUtils.shuffle(cardUtils.generateDeck());\n    const players = [];\n    const initialLog = ['Game started!'];\n\n    // Randomly determine the first player (0 to numPlayers-1)\n    const firstPlayerIndex = Math.floor(Math.random() * numPlayers);\n    \n    // Create all players\n    for (let i = 0; i < numPlayers; i++) {\n        const playerName = i === 0 ? 'You' : `Bot ${i}`;\n        const { drawn, remaining } = cardUtils.drawCards(deck, 1);\n        const drawnCard = drawn[0];\n        deck = remaining;\n\n        const player = {\n            id: i,\n            name: playerName,\n            isHuman: i === 0,\n            cards: [...drawn],\n            hiddenCards: i === 0 ? [] : [...drawn],\n            visibleCards: i === 0 ? [...drawn] : [],\n            total: cardUtils.calculateTotal(drawn),\n            status: 'active' // active, holding, eliminated, winner\n        };\n\n        players.push(player);\n\n        if (i === 0) {\n            initialLog.push(`You drew ${cardUtils.getCardName(drawnCard)}. Total: ${player.total}`);\n        } else {\n            initialLog.push(`${playerName} drew a card.`);\n        }\n    }\n\n    // Log who goes first\n    const firstPlayerName = players[firstPlayerIndex].isHuman ? 'You' : players[firstPlayerIndex].name;\n    initialLog.push(`${firstPlayerName} will go first.`);\n    \n    return {\n        phase: 'playing',\n        players,\n        deck,\n        currentPlayerIndex: firstPlayerIndex,\n        winner: null,\n        gameLog: initialLog,\n        gameId: Date.now(),\n        cardBackStyle: cardBackStyle\n    };\n}\n\n// Handle drawing a card\n// export function handleDrawCard(gameState, currentPlayer, playerIndex) {\n//     // Draw a card from the deck\n//     const { drawn, remaining } = cardUtils.drawCards(gameState.deck, 1);\n//     const drawnCard = drawn[0];\n\n//     // Update player's cards and total\n//     const updatedPlayers = [...gameState.players];\n//     const player = updatedPlayers[playerIndex];\n\n//     player.cards = [...player.cards, drawnCard];\n//     player.visibleCards = [...player.visibleCards, drawnCard];\n//     player.total = cardUtils.calculateTotal(player.cards);\n\n//     // Log the action\n//     const actionLog = `${player.name} drew ${cardUtils.getCardName(drawnCard)}. Total: ${player.total}`;\n\n//     // Check if player reached exactly 17\n//     if (player.total === 17) {\n//         player.status = 'winner';\n//         return {\n//             ...gameState,\n//             players: updatedPlayers,\n//             deck: remaining,\n//             phase: 'gameOver',\n//             winner: playerIndex,\n//             gameLog: [...gameState.gameLog, actionLog, `${player.name} won with exactly 17!`]\n//         };\n//     }\n\n//     // Check if player exceeded 17\n//     if (player.total > 17) {\n//         player.status = 'eliminated';\n        \n//         // Check if all players are eliminated or if the game is over\n//         const gameEndCheck = checkGameEnd(\n//             updatedPlayers,\n//             `${player.name} exceeded 17 and is eliminated!`\n//         );\n\n//         if (gameEndCheck.gameOver) {\n//             return {\n//                 ...gameState,\n//                 players: gameEndCheck.players,\n//                 deck: remaining,\n//                 phase: 'revealing',\n//                 revealPhase: true,\n//                 pendingWinner: gameEndCheck.winner,\n//                 pendingWinnerMessage: gameEndCheck.winnerMessage,\n//                 gameLog: [...gameState.gameLog, actionLog, ...gameEndCheck.message]\n//             };\n//         }\n\n//         // Find next active player\n//         let nextPlayerIndex = (playerIndex + 1) % gameState.players.length;\n//         while (\n//             nextPlayerIndex !== playerIndex &&\n//             (updatedPlayers[nextPlayerIndex].status === 'eliminated' ||\n//                 updatedPlayers[nextPlayerIndex].status === 'holding')\n//         ) {\n//             nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;\n//         }\n\n//         return {\n//             ...gameState,\n//             players: updatedPlayers,\n//             deck: remaining,\n//             currentPlayerIndex: nextPlayerIndex,\n//             gameLog: [\n//                 ...gameState.gameLog, \n//                 actionLog,\n//                 `${player.name} exceeded 17 and is eliminated!`,\n//                 `${updatedPlayers[nextPlayerIndex].name}'s turn.`\n//             ]\n//         };\n//     }\n\n//     // Standard case - continue game\n//     return {\n//         ...gameState,\n//         players: updatedPlayers,\n//         deck: remaining,\n//         gameLog: [...gameState.gameLog, actionLog]\n//     };\n// }\n\nexport function handleDrawCard(gameState, player, playerIndex) {\n    // Draw card\n    const { drawn, remaining } = cardUtils.drawCards(gameState.deck, 1);\n    const drawnCard = drawn[0];\n    const newTotal = player.total + cardUtils.getCardValue(drawnCard);\n    \n    // Update player cards\n    const updatedPlayers = [...gameState.players];\n    const updatedPlayer = {\n        ...player,\n        cards: [...player.cards, drawnCard],\n        visibleCards: [...player.visibleCards, drawnCard],\n        total: newTotal\n    };\n    \n    // Create log message\n    let actionLog = `${player.name} drew ${cardUtils.getCardName(drawnCard)}. Total: ${newTotal}`;\n    \n    // Check if player is eliminated (bust)\n    if (newTotal > 17) {\n        updatedPlayer.status = 'eliminated';\n        \n        // Find next active player\n        let nextPlayerIndex = (playerIndex + 1) % gameState.players.length;\n        while (\n            nextPlayerIndex !== playerIndex &&\n            (updatedPlayers[nextPlayerIndex].status === 'eliminated' ||\n                updatedPlayers[nextPlayerIndex].status === 'holding')\n        ) {\n            nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;\n        }\n        \n        // Check if all players are done\n        const allDone = updatedPlayers.every(p => p.status !== 'active');\n        if (allDone) {\n            const gameEndCheck = checkGameEnd(\n                updatedPlayers, \n                `${player.name} drew ${cardUtils.getCardName(drawnCard)} and was eliminated with a total of ${newTotal}.`\n            );\n            \n            if (gameEndCheck.gameOver) {\n                return {\n                    ...gameState,\n                    players: gameEndCheck.players,\n                    deck: remaining,\n                    phase: 'revealing',\n                    revealPhase: true,\n                    pendingWinner: gameEndCheck.winner,\n                    pendingWinnerMessage: gameEndCheck.winnerMessage,\n                    gameLog: [...gameState.gameLog, ...gameEndCheck.message]\n                };\n            }\n        }\n\n        return {\n            ...gameState,\n            players: updatedPlayers,\n            deck: remaining,\n            currentPlayerIndex: nextPlayerIndex,\n            gameLog: [\n                ...gameState.gameLog, \n                actionLog,\n                `${player.name} exceeded 17 and is eliminated!`,\n                `${updatedPlayers[nextPlayerIndex].name}'s turn.`\n            ]\n        };\n    }\n    \n    // Check if player wins by having exactly 17 or 7 cards\n    if (newTotal === 17 || updatedPlayer.cards.length === 7) {\n        updatedPlayer.status = 'winner';\n        \n        return {\n            ...gameState,\n            players: updatedPlayers,\n            deck: remaining,\n            phase: 'gameOver',\n            winner: playerIndex,\n            gameLog: [\n                ...gameState.gameLog, \n                actionLog,\n                `${player.name} wins the game!`\n            ]\n        };\n    }\n    \n    // For human players, stay on their turn unless they get exactly 17 or 7 cards\n    if (player.isHuman) {\n        return {\n            ...gameState,\n            players: updatedPlayers,\n            deck: remaining,\n            gameLog: [...gameState.gameLog, actionLog]\n        };\n    }\n    \n    // For AI players, move to next\n    let nextPlayerIndex = (playerIndex + 1) % gameState.players.length;\n    while (\n        nextPlayerIndex !== playerIndex &&\n        (updatedPlayers[nextPlayerIndex].status === 'eliminated' ||\n            updatedPlayers[nextPlayerIndex].status === 'holding')\n    ) {\n        nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;\n    }\n    \n    return {\n        ...gameState,\n        players: updatedPlayers,\n        deck: remaining,\n        currentPlayerIndex: nextPlayerIndex,\n        gameLog: [\n            ...gameState.gameLog, \n            actionLog,\n            `${updatedPlayers[nextPlayerIndex].name}'s turn.`\n        ]\n    };\n}\n\n// Handle player holding\nexport function handleHold(gameState, currentPlayer, playerIndex) {\n    // Check if player has at least 2 cards (initial card + at least one drawn card)\n    if (currentPlayer.cards.length < 2) {\n        return gameState; // Cannot hold until drawing at least one more card\n    }\n    \n    // Check if player has reached at least 11 points\n    if (currentPlayer.total < 11) {\n        return gameState; // Cannot hold below 11\n    }\n    const updatedPlayers = [...gameState.players];\n    updatedPlayers[playerIndex].status = 'holding';\n\n    // Find next active player\n    let nextPlayerIndex = (playerIndex + 1) % gameState.players.length;\n    while (\n        nextPlayerIndex !== playerIndex &&\n        (updatedPlayers[nextPlayerIndex].status === 'eliminated' ||\n            updatedPlayers[nextPlayerIndex].status === 'holding')\n    ) {\n        nextPlayerIndex = (nextPlayerIndex + 1) % gameState.players.length;\n    }\n\n    const allDone = updatedPlayers.every((p) => p.status !== 'active');\n\n    if (allDone) {\n        const gameEndCheck = checkGameEnd(\n            updatedPlayers, \n            `${currentPlayer.name} decided to hold with a total of ${currentPlayer.total}.`\n        );\n        \n        if (gameEndCheck.gameOver) {\n            return {\n                ...gameState,\n                players: gameEndCheck.players,\n                phase: 'revealing',\n                revealPhase: true,\n                pendingWinner: gameEndCheck.winner,\n                pendingWinnerMessage: gameEndCheck.winnerMessage,\n                gameLog: [...gameState.gameLog, ...gameEndCheck.message]\n            };\n        }\n    }\n\n    return {\n        ...gameState,\n        players: updatedPlayers,\n        currentPlayerIndex: nextPlayerIndex,\n        gameLog: [\n            ...gameState.gameLog, \n            `${currentPlayer.name} decided to hold with a total of ${currentPlayer.total}.`, \n            `${updatedPlayers[nextPlayerIndex].name}'s turn.`\n        ]\n    };\n}\n\n// Check if the game has ended\nexport function checkGameEnd(players, currentAction = '') {\n    const allDone = players.every((p) => p.status !== 'active');\n\n    if (allDone) {\n        const { winnerIndex, winMessage } = determineWinner(players);\n\n        players.forEach((player) => {\n            if (player.status !== 'eliminated') {\n                player.status = 'revealing';\n            }\n        });\n\n        return {\n            gameOver: true,\n            revealPhase: true,\n            players,\n            winner: winnerIndex,\n            winnerMessage: winMessage,\n            message: [currentAction].filter(Boolean)\n        };\n    }\n\n    return { gameOver: false };\n}\n\n// Determine the winner based on game rules\nexport function determineWinner(players) {\n    const exactWinner = players.findIndex((p) => p.total === 17);\n    if (exactWinner !== -1) {\n        return {\n            winnerIndex: exactWinner,\n            winMessage: `${players[exactWinner].name} won with exactly 17!`,\n        };\n    }\n\n    const allEliminated = players.every((p) => p.status === 'eliminated');\n    if (allEliminated) {\n        return {\n            winnerIndex: -1,\n            winMessage: 'All players exceeded 17. Game is void.',\n        };\n    }\n\n    let maxTotal = 0;\n    let winnerIndex = -1;\n\n    players.forEach((player, idx) => {\n        if (player.status !== 'eliminated' && player.total <= 17 && player.total > maxTotal) {\n            maxTotal = player.total;\n            winnerIndex = idx;\n        }\n    });\n\n    if (winnerIndex !== -1) {\n        return {\n            winnerIndex,\n            winMessage: `${players[winnerIndex].name} wins with a total of ${maxTotal}!`,\n        };\n    }\n\n    return {\n        winnerIndex: -1,\n        winMessage: 'No winner could be determined.',\n    };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}