{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useCallback } from 'react';\nimport { cardUtils } from '../../services/cardUtils'; // Update path\nimport { handleDrawCard, handleHold } from './gameLogic';\nexport default function useBotAI(gameState, setGameState) {\n  _s();\n  // Game of 17 specific bot decision-making logic\n  const shouldBotDraw = (botCards, otherPlayers) => {\n    // If bot has only 1 card, must draw (game rule requires at least 2 cards)\n    if (botCards.length < 2) return true;\n    const botTotal = cardUtils.calculateTotal(botCards);\n\n    // Base probabilities - never draw if at or over 17\n    if (botTotal >= 17) return false;\n\n    // Must draw if under 11 (game rule)\n    if (botTotal < 11) return true;\n\n    // Count number of other players still in the game\n    const activeOtherPlayers = otherPlayers.filter(p => p.status !== 'eliminated').length;\n    if (activeOtherPlayers == 0) return false; // No other players and have more than 10, don't draw\n\n    // Default probability based on bot's current total\n    let drawProbability;\n\n    // Check if any holding players are likely ahead\n    const holdingPlayersAhead = otherPlayers.some(playerData => {\n      if (playerData.status !== 'holding') return false;\n\n      // Calculate visible total - for human player exclude first card, for bots include all visible cards\n      const visibleTotal = playerData.isHuman ? cardUtils.calculateTotal(playerData.visibleCards.slice(1)) : cardUtils.calculateTotal(playerData.visibleCards);\n\n      // Consider a player ahead if their visible cards suggest they're close to 17\n      // (remember we can't see their hidden card)\n      return visibleTotal >= botTotal;\n    });\n    if (holdingPlayersAhead) {\n      drawProbability = 1; // Definetely draw\n    }\n\n    // Count holding players directly with filter\n    const holdingPlayersCount = otherPlayers.filter(player => player.status === 'holding').length;\n\n    // Factor in both holding and remaining active players\n    const holdingFactor = 0.05 * holdingPlayersCount;\n    const remainingActiveFactor = 0.05 * (activeOtherPlayers - holdingPlayersCount); // Adjust the weight as needed\n\n    switch (botTotal) {\n      case 11:\n        drawProbability = 0.3 + holdingFactor + remainingActiveFactor;\n        break;\n      case 12:\n        drawProbability = 0.25 + holdingFactor + remainingActiveFactor;\n        break;\n      case 13:\n        drawProbability = 0.2 + holdingFactor + remainingActiveFactor;\n        break;\n      case 14:\n        drawProbability = 0.1 + holdingFactor + remainingActiveFactor;\n        break;\n      case 15:\n        drawProbability = 0.05 + holdingFactor + remainingActiveFactor;\n        break;\n      case 16:\n        drawProbability = 0.05 + holdingFactor;\n        break;\n      default:\n        drawProbability = 0;\n    }\n\n    // Adjust strategy based on number of opponents\n    if (activeOtherPlayers <= 1) {\n      // More conservative with fewer opponents\n      drawProbability *= 0.8;\n    }\n\n    // Ensure probability is within bounds\n    drawProbability = Math.max(0, Math.min(1, drawProbability));\n    console.log(`Bot decision (Total: ${botTotal}): Draw probability ${drawProbability.toFixed(2)}, Active: ${activeOtherPlayers}, Holding: ${holdingPlayersCount}, Will draw: ${Math.random() < drawProbability}`);\n    return Math.random() < drawProbability;\n  };\n  const processBotTurn = useCallback(() => {\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n\n    // Get data from all other players\n    const otherPlayersData = gameState.players.filter((player, index) => index !== gameState.currentPlayerIndex);\n\n    // Bot decision based on visible information\n    let updatedGameState;\n    if (shouldBotDraw(currentPlayer.cards, otherPlayersData)) {\n      updatedGameState = handleDrawCard(gameState, currentPlayer, gameState.currentPlayerIndex);\n    } else {\n      updatedGameState = handleHold(gameState, currentPlayer, gameState.currentPlayerIndex);\n    }\n    setGameState(updatedGameState);\n  }, [gameState, setGameState]);\n  return {\n    processBotTurn\n  };\n}\n_s(useBotAI, \"ph+a3mvihLl3fb35JehTA4aTodg=\");","map":{"version":3,"names":["useCallback","cardUtils","handleDrawCard","handleHold","useBotAI","gameState","setGameState","_s","shouldBotDraw","botCards","otherPlayers","length","botTotal","calculateTotal","activeOtherPlayers","filter","p","status","drawProbability","holdingPlayersAhead","some","playerData","visibleTotal","isHuman","visibleCards","slice","holdingPlayersCount","player","holdingFactor","remainingActiveFactor","Math","max","min","console","log","toFixed","random","processBotTurn","currentPlayer","players","currentPlayerIndex","otherPlayersData","index","updatedGameState","cards"],"sources":["/Users/pradipbade/Documents/Projects/Small Projects/react-3d-card-game/src/games/gameOf17/useBotAI.js"],"sourcesContent":["import { useCallback } from 'react';\nimport { cardUtils } from '../../services/cardUtils'; // Update path\nimport { handleDrawCard, handleHold } from './gameLogic';\nexport default function useBotAI(gameState, setGameState) {\n    // Game of 17 specific bot decision-making logic\n    const shouldBotDraw = (botCards, otherPlayers) => {\n        // If bot has only 1 card, must draw (game rule requires at least 2 cards)\n        if (botCards.length < 2) return true;\n        const botTotal = cardUtils.calculateTotal(botCards);\n\n        // Base probabilities - never draw if at or over 17\n        if (botTotal >= 17) return false;\n\n        // Must draw if under 11 (game rule)\n        if (botTotal < 11) return true;\n\n        // Count number of other players still in the game\n        const activeOtherPlayers = otherPlayers.filter(p => p.status !== 'eliminated').length;\n        if (activeOtherPlayers == 0) return false;  // No other players and have more than 10, don't draw\n\n        // Default probability based on bot's current total\n        let drawProbability;\n\n\n        // Check if any holding players are likely ahead\n        const holdingPlayersAhead = otherPlayers.some(playerData => {\n            if (playerData.status !== 'holding') return false;\n\n            // Calculate visible total - for human player exclude first card, for bots include all visible cards\n            const visibleTotal = playerData.isHuman\n                ? cardUtils.calculateTotal(playerData.visibleCards.slice(1))\n                : cardUtils.calculateTotal(playerData.visibleCards);\n\n            // Consider a player ahead if their visible cards suggest they're close to 17\n            // (remember we can't see their hidden card)\n            return visibleTotal >= botTotal;\n        });\n\n        if (holdingPlayersAhead) {\n            drawProbability = 1; // Definetely draw\n        }\n\n        // Count holding players directly with filter\n        const holdingPlayersCount = otherPlayers.filter(player => player.status === 'holding').length;\n\n        // Factor in both holding and remaining active players\n        const holdingFactor = 0.05 * holdingPlayersCount;\n        const remainingActiveFactor = 0.05 * (activeOtherPlayers-holdingPlayersCount); // Adjust the weight as needed\n\n        switch (botTotal) {\n            case 11:\n                drawProbability = 0.3 + holdingFactor + remainingActiveFactor; break;\n            case 12:\n                drawProbability = 0.25 + holdingFactor + remainingActiveFactor; break;\n            case 13:\n                drawProbability = 0.2 + holdingFactor + remainingActiveFactor; break;\n            case 14:\n                drawProbability = 0.1 + holdingFactor + remainingActiveFactor; break;\n            case 15:\n                drawProbability = 0.05 + holdingFactor + remainingActiveFactor; break;\n            case 16:\n                drawProbability = 0.05 + holdingFactor; break;\n            default:\n                drawProbability = 0;\n        }\n\n\n\n        // Adjust strategy based on number of opponents\n        if (activeOtherPlayers <= 1) {\n            // More conservative with fewer opponents\n            drawProbability *= 0.8;\n        }\n\n\n\n        // Ensure probability is within bounds\n        drawProbability = Math.max(0, Math.min(1, drawProbability));\n        console.log(`Bot decision (Total: ${botTotal}): Draw probability ${drawProbability.toFixed(2)}, Active: ${activeOtherPlayers}, Holding: ${holdingPlayersCount}, Will draw: ${Math.random() < drawProbability}`);\n        return Math.random() < drawProbability;\n    };\n\n    const processBotTurn = useCallback(() => {\n        const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n\n        // Get data from all other players\n        const otherPlayersData = gameState.players\n            .filter((player, index) => index !== gameState.currentPlayerIndex);\n\n        // Bot decision based on visible information\n        let updatedGameState;\n\n        if (shouldBotDraw(currentPlayer.cards, otherPlayersData)) {\n            updatedGameState = handleDrawCard(gameState, currentPlayer, gameState.currentPlayerIndex);\n        } else {\n            updatedGameState = handleHold(gameState, currentPlayer, gameState.currentPlayerIndex);\n        }\n\n        setGameState(updatedGameState);\n    }, [gameState, setGameState]);\n\n    return { processBotTurn };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}