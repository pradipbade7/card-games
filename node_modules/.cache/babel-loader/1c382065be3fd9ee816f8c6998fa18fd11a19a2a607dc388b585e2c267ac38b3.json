{"ast":null,"code":"import { MeshStandardMaterial } from 'three';\nclass MeshReflectorMaterial extends MeshStandardMaterial {\n  constructor(parameters = {}) {\n    super(parameters);\n    this._debug = {\n      value: 0\n    };\n    this._tDepth = {\n      value: null\n    };\n    this._distortionMap = {\n      value: null\n    };\n    this._tDiffuse = {\n      value: null\n    };\n    this._tDiffuseBlur = {\n      value: null\n    };\n    this._textureMatrix = {\n      value: null\n    };\n    this._hasBlur = {\n      value: false\n    };\n    this._mirror = {\n      value: 0.0\n    };\n    this._mixBlur = {\n      value: 0.0\n    };\n    this._blurStrength = {\n      value: 0.5\n    };\n    this._minDepthThreshold = {\n      value: 0.9\n    };\n    this._maxDepthThreshold = {\n      value: 1\n    };\n    this._depthScale = {\n      value: 0\n    };\n    this._depthToBlurRatioBias = {\n      value: 0.25\n    };\n    this._distortion = {\n      value: 1\n    };\n    this.setValues(parameters);\n  }\n  onBeforeCompile(shader) {\n    var _shader$defines;\n    if (!((_shader$defines = shader.defines) != null && _shader$defines.USE_UV)) {\n      shader.defines.USE_UV = '';\n    }\n    shader.uniforms.debug = this._debug;\n    shader.uniforms.hasBlur = this._hasBlur;\n    shader.uniforms.tDiffuse = this._tDiffuse;\n    shader.uniforms.tDepth = this._tDepth;\n    shader.uniforms.distortionMap = this._distortionMap;\n    shader.uniforms.tDiffuseBlur = this._tDiffuseBlur;\n    shader.uniforms.textureMatrix = this._textureMatrix;\n    shader.uniforms.mirror = this._mirror;\n    shader.uniforms.mixBlur = this._mixBlur;\n    shader.uniforms.mixStrength = this._blurStrength;\n    shader.uniforms.minDepthThreshold = this._minDepthThreshold;\n    shader.uniforms.maxDepthThreshold = this._maxDepthThreshold;\n    shader.uniforms.depthScale = this._depthScale;\n    shader.uniforms.depthToBlurRatioBias = this._depthToBlurRatioBias;\n    shader.uniforms.distortion = this._distortion;\n    shader.vertexShader = `\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;     \n      ${shader.vertexShader}`;\n    shader.vertexShader = shader.vertexShader.replace('#include <project_vertex>', `#include <project_vertex>\n        my_vUv = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`);\n    shader.fragmentShader = `\n        uniform int debug;\n        uniform sampler2D tDiffuse;\n        uniform sampler2D tDiffuseBlur;\n        uniform sampler2D tDepth;\n        uniform sampler2D distortionMap;\n        uniform float distortion;\n        uniform float cameraNear;\n\t\t\t  uniform float cameraFar;\n        uniform bool hasBlur;\n        uniform float mixBlur;\n        uniform float mirror;\n        uniform float mixStrength;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec4 my_vUv;        \n        ${shader.fragmentShader}`;\n    shader.fragmentShader = shader.fragmentShader.replace('#include <emissivemap_fragment>', `#include <emissivemap_fragment>\n    \n      float distortionFactor = 0.0;\n      #ifdef USE_DISTORTION\n        distortionFactor = texture2D(distortionMap, vUv).r * distortion;\n      #endif\n\n      vec4 new_vUv = my_vUv;\n      new_vUv.x += distortionFactor;\n      new_vUv.y += distortionFactor;\n\n      vec4 base = texture2DProj(tDiffuse, new_vUv);\n      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);\n      \n      vec4 merge = base;\n      \n      #ifdef USE_NORMALMAP\n        vec2 normal_uv = vec2(0.0);\n        vec4 normalColor = texture2D(normalMap, vUv * normalScale);\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n        vec3 coord = new_vUv.xyz / new_vUv.w;\n        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\n        vec4 base_normal = texture2D(tDiffuse, normal_uv);\n        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);\n        merge = base_normal;\n        blur = blur_normal;\n      #endif\n\n      float depthFactor = 0.0001;\n      float blurFactor = 0.0;\n\n      #ifdef USE_DEPTH\n        vec4 depth = texture2DProj(tDepth, new_vUv);\n        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n        depthFactor *= depthScale;\n        depthFactor = max(0.0001, min(1.0, depthFactor));\n\n        #ifdef USE_BLUR\n          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\n          merge = merge * min(1.0, depthFactor + 0.5);;\n        #else\n          merge = merge * depthFactor;\n        #endif\n  \n      #endif\n\n      float reflectorRoughnessFactor = roughness;\n      #ifdef USE_ROUGHNESSMAP\n        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\n        reflectorRoughnessFactor *= reflectorTexelRoughness.g;\n      #endif\n      \n      #ifdef USE_BLUR\n        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\n        merge = mix(merge, blur, blurFactor);\n      #endif\n\n      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + merge.rgb * mixStrength);           \n      diffuseColor = sRGBToLinear(diffuseColor);\n      \n      if (debug == 1) {\n        diffuseColor = sRGBToLinear(vec4(vec3(depthFactor), 1.0));\n      }\n      if (debug == 2) {\n        diffuseColor = sRGBToLinear(vec4(vec3(blurFactor), 1.0));\n      }\n      if (debug == 3) {\n        diffuseColor = sRGBToLinear(texture2DProj(tDiffuse, new_vUv));\n      }\n      if (debug == 4) {\n        diffuseColor = sRGBToLinear(texture2DProj(tDiffuseBlur, new_vUv));\n      }\n      `);\n  }\n  get tDiffuse() {\n    return this._tDiffuse.value;\n  }\n  set tDiffuse(v) {\n    this._tDiffuse.value = v;\n  }\n  get tDepth() {\n    return this._tDepth.value;\n  }\n  set tDepth(v) {\n    this._tDepth.value = v;\n  }\n  get distortionMap() {\n    return this._distortionMap.value;\n  }\n  set distortionMap(v) {\n    this._distortionMap.value = v;\n  }\n  get tDiffuseBlur() {\n    return this._tDiffuseBlur.value;\n  }\n  set tDiffuseBlur(v) {\n    this._tDiffuseBlur.value = v;\n  }\n  get textureMatrix() {\n    return this._textureMatrix.value;\n  }\n  set textureMatrix(v) {\n    this._textureMatrix.value = v;\n  }\n  get hasBlur() {\n    return this._hasBlur.value;\n  }\n  set hasBlur(v) {\n    this._hasBlur.value = v;\n  }\n  get mirror() {\n    return this._mirror.value;\n  }\n  set mirror(v) {\n    this._mirror.value = v;\n  }\n  get mixBlur() {\n    return this._mixBlur.value;\n  }\n  set mixBlur(v) {\n    this._mixBlur.value = v;\n  }\n  get mixStrength() {\n    return this._blurStrength.value;\n  }\n  set mixStrength(v) {\n    this._blurStrength.value = v;\n  }\n  get minDepthThreshold() {\n    return this._minDepthThreshold.value;\n  }\n  set minDepthThreshold(v) {\n    this._minDepthThreshold.value = v;\n  }\n  get maxDepthThreshold() {\n    return this._maxDepthThreshold.value;\n  }\n  set maxDepthThreshold(v) {\n    this._maxDepthThreshold.value = v;\n  }\n  get depthScale() {\n    return this._depthScale.value;\n  }\n  set depthScale(v) {\n    this._depthScale.value = v;\n  }\n  get debug() {\n    return this._debug.value;\n  }\n  set debug(v) {\n    this._debug.value = v;\n  }\n  get depthToBlurRatioBias() {\n    return this._depthToBlurRatioBias.value;\n  }\n  set depthToBlurRatioBias(v) {\n    this._depthToBlurRatioBias.value = v;\n  }\n  get distortion() {\n    return this._distortion.value;\n  }\n  set distortion(v) {\n    this._distortion.value = v;\n  }\n}\nexport { MeshReflectorMaterial };","map":{"version":3,"names":["MeshStandardMaterial","MeshReflectorMaterial","constructor","parameters","_debug","value","_tDepth","_distortionMap","_tDiffuse","_tDiffuseBlur","_textureMatrix","_hasBlur","_mirror","_mixBlur","_blurStrength","_minDepthThreshold","_maxDepthThreshold","_depthScale","_depthToBlurRatioBias","_distortion","setValues","onBeforeCompile","shader","_shader$defines","defines","USE_UV","uniforms","debug","hasBlur","tDiffuse","tDepth","distortionMap","tDiffuseBlur","textureMatrix","mirror","mixBlur","mixStrength","minDepthThreshold","maxDepthThreshold","depthScale","depthToBlurRatioBias","distortion","vertexShader","replace","fragmentShader","v"],"sources":["/Users/pradipbade/Documents/Projects/Small Projects/react-3d-card-game/node_modules/@react-three/drei/materials/MeshReflectorMaterial.js"],"sourcesContent":["import { MeshStandardMaterial } from 'three';\n\nclass MeshReflectorMaterial extends MeshStandardMaterial {\n  constructor(parameters = {}) {\n    super(parameters);\n    this._debug = {\n      value: 0\n    };\n    this._tDepth = {\n      value: null\n    };\n    this._distortionMap = {\n      value: null\n    };\n    this._tDiffuse = {\n      value: null\n    };\n    this._tDiffuseBlur = {\n      value: null\n    };\n    this._textureMatrix = {\n      value: null\n    };\n    this._hasBlur = {\n      value: false\n    };\n    this._mirror = {\n      value: 0.0\n    };\n    this._mixBlur = {\n      value: 0.0\n    };\n    this._blurStrength = {\n      value: 0.5\n    };\n    this._minDepthThreshold = {\n      value: 0.9\n    };\n    this._maxDepthThreshold = {\n      value: 1\n    };\n    this._depthScale = {\n      value: 0\n    };\n    this._depthToBlurRatioBias = {\n      value: 0.25\n    };\n    this._distortion = {\n      value: 1\n    };\n    this.setValues(parameters);\n  }\n\n  onBeforeCompile(shader) {\n    var _shader$defines;\n\n    if (!((_shader$defines = shader.defines) != null && _shader$defines.USE_UV)) {\n      shader.defines.USE_UV = '';\n    }\n\n    shader.uniforms.debug = this._debug;\n    shader.uniforms.hasBlur = this._hasBlur;\n    shader.uniforms.tDiffuse = this._tDiffuse;\n    shader.uniforms.tDepth = this._tDepth;\n    shader.uniforms.distortionMap = this._distortionMap;\n    shader.uniforms.tDiffuseBlur = this._tDiffuseBlur;\n    shader.uniforms.textureMatrix = this._textureMatrix;\n    shader.uniforms.mirror = this._mirror;\n    shader.uniforms.mixBlur = this._mixBlur;\n    shader.uniforms.mixStrength = this._blurStrength;\n    shader.uniforms.minDepthThreshold = this._minDepthThreshold;\n    shader.uniforms.maxDepthThreshold = this._maxDepthThreshold;\n    shader.uniforms.depthScale = this._depthScale;\n    shader.uniforms.depthToBlurRatioBias = this._depthToBlurRatioBias;\n    shader.uniforms.distortion = this._distortion;\n    shader.vertexShader = `\n        uniform mat4 textureMatrix;\n        varying vec4 my_vUv;     \n      ${shader.vertexShader}`;\n    shader.vertexShader = shader.vertexShader.replace('#include <project_vertex>', `#include <project_vertex>\n        my_vUv = textureMatrix * vec4( position, 1.0 );\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );`);\n    shader.fragmentShader = `\n        uniform int debug;\n        uniform sampler2D tDiffuse;\n        uniform sampler2D tDiffuseBlur;\n        uniform sampler2D tDepth;\n        uniform sampler2D distortionMap;\n        uniform float distortion;\n        uniform float cameraNear;\n\t\t\t  uniform float cameraFar;\n        uniform bool hasBlur;\n        uniform float mixBlur;\n        uniform float mirror;\n        uniform float mixStrength;\n        uniform float minDepthThreshold;\n        uniform float maxDepthThreshold;\n        uniform float depthScale;\n        uniform float depthToBlurRatioBias;\n        varying vec4 my_vUv;        \n        ${shader.fragmentShader}`;\n    shader.fragmentShader = shader.fragmentShader.replace('#include <emissivemap_fragment>', `#include <emissivemap_fragment>\n    \n      float distortionFactor = 0.0;\n      #ifdef USE_DISTORTION\n        distortionFactor = texture2D(distortionMap, vUv).r * distortion;\n      #endif\n\n      vec4 new_vUv = my_vUv;\n      new_vUv.x += distortionFactor;\n      new_vUv.y += distortionFactor;\n\n      vec4 base = texture2DProj(tDiffuse, new_vUv);\n      vec4 blur = texture2DProj(tDiffuseBlur, new_vUv);\n      \n      vec4 merge = base;\n      \n      #ifdef USE_NORMALMAP\n        vec2 normal_uv = vec2(0.0);\n        vec4 normalColor = texture2D(normalMap, vUv * normalScale);\n        vec3 my_normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );\n        vec3 coord = new_vUv.xyz / new_vUv.w;\n        normal_uv = coord.xy + coord.z * my_normal.xz * 0.05;\n        vec4 base_normal = texture2D(tDiffuse, normal_uv);\n        vec4 blur_normal = texture2D(tDiffuseBlur, normal_uv);\n        merge = base_normal;\n        blur = blur_normal;\n      #endif\n\n      float depthFactor = 0.0001;\n      float blurFactor = 0.0;\n\n      #ifdef USE_DEPTH\n        vec4 depth = texture2DProj(tDepth, new_vUv);\n        depthFactor = smoothstep(minDepthThreshold, maxDepthThreshold, 1.0-(depth.r * depth.a));\n        depthFactor *= depthScale;\n        depthFactor = max(0.0001, min(1.0, depthFactor));\n\n        #ifdef USE_BLUR\n          blur = blur * min(1.0, depthFactor + depthToBlurRatioBias);\n          merge = merge * min(1.0, depthFactor + 0.5);;\n        #else\n          merge = merge * depthFactor;\n        #endif\n  \n      #endif\n\n      float reflectorRoughnessFactor = roughness;\n      #ifdef USE_ROUGHNESSMAP\n        vec4 reflectorTexelRoughness = texture2D( roughnessMap, vUv );\n        reflectorRoughnessFactor *= reflectorTexelRoughness.g;\n      #endif\n      \n      #ifdef USE_BLUR\n        blurFactor = min(1.0, mixBlur * reflectorRoughnessFactor);\n        merge = mix(merge, blur, blurFactor);\n      #endif\n\n      diffuseColor.rgb = diffuseColor.rgb * ((1.0 - min(1.0, mirror)) + merge.rgb * mixStrength);           \n      diffuseColor = sRGBToLinear(diffuseColor);\n      \n      if (debug == 1) {\n        diffuseColor = sRGBToLinear(vec4(vec3(depthFactor), 1.0));\n      }\n      if (debug == 2) {\n        diffuseColor = sRGBToLinear(vec4(vec3(blurFactor), 1.0));\n      }\n      if (debug == 3) {\n        diffuseColor = sRGBToLinear(texture2DProj(tDiffuse, new_vUv));\n      }\n      if (debug == 4) {\n        diffuseColor = sRGBToLinear(texture2DProj(tDiffuseBlur, new_vUv));\n      }\n      `);\n  }\n\n  get tDiffuse() {\n    return this._tDiffuse.value;\n  }\n\n  set tDiffuse(v) {\n    this._tDiffuse.value = v;\n  }\n\n  get tDepth() {\n    return this._tDepth.value;\n  }\n\n  set tDepth(v) {\n    this._tDepth.value = v;\n  }\n\n  get distortionMap() {\n    return this._distortionMap.value;\n  }\n\n  set distortionMap(v) {\n    this._distortionMap.value = v;\n  }\n\n  get tDiffuseBlur() {\n    return this._tDiffuseBlur.value;\n  }\n\n  set tDiffuseBlur(v) {\n    this._tDiffuseBlur.value = v;\n  }\n\n  get textureMatrix() {\n    return this._textureMatrix.value;\n  }\n\n  set textureMatrix(v) {\n    this._textureMatrix.value = v;\n  }\n\n  get hasBlur() {\n    return this._hasBlur.value;\n  }\n\n  set hasBlur(v) {\n    this._hasBlur.value = v;\n  }\n\n  get mirror() {\n    return this._mirror.value;\n  }\n\n  set mirror(v) {\n    this._mirror.value = v;\n  }\n\n  get mixBlur() {\n    return this._mixBlur.value;\n  }\n\n  set mixBlur(v) {\n    this._mixBlur.value = v;\n  }\n\n  get mixStrength() {\n    return this._blurStrength.value;\n  }\n\n  set mixStrength(v) {\n    this._blurStrength.value = v;\n  }\n\n  get minDepthThreshold() {\n    return this._minDepthThreshold.value;\n  }\n\n  set minDepthThreshold(v) {\n    this._minDepthThreshold.value = v;\n  }\n\n  get maxDepthThreshold() {\n    return this._maxDepthThreshold.value;\n  }\n\n  set maxDepthThreshold(v) {\n    this._maxDepthThreshold.value = v;\n  }\n\n  get depthScale() {\n    return this._depthScale.value;\n  }\n\n  set depthScale(v) {\n    this._depthScale.value = v;\n  }\n\n  get debug() {\n    return this._debug.value;\n  }\n\n  set debug(v) {\n    this._debug.value = v;\n  }\n\n  get depthToBlurRatioBias() {\n    return this._depthToBlurRatioBias.value;\n  }\n\n  set depthToBlurRatioBias(v) {\n    this._depthToBlurRatioBias.value = v;\n  }\n\n  get distortion() {\n    return this._distortion.value;\n  }\n\n  set distortion(v) {\n    this._distortion.value = v;\n  }\n\n}\n\nexport { MeshReflectorMaterial };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}