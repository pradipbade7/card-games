{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useCallback } from 'react';\nimport { cardUtils } from '../../services/cardUtils'; // Update path\nimport { handleDrawCard, handleHold } from './gameLogic';\nexport default function useBotAI(gameState, setGameState) {\n  _s();\n  // Game of 17 specific bot decision-making logic\n  const shouldBotDraw = (botCards, otherPlayers) => {\n    const botTotal = cardUtils.calculateTotal(botCards);\n\n    // Base probabilities - never draw if at or over 17\n    if (botTotal >= 17) return false;\n\n    // Must draw if under 11 (game rule)\n    if (botTotal < 11) return true;\n\n    // Count number of other players still in the game\n    const activeOtherPlayers = otherPlayers.filter(p => p.status !== 'eliminated').length;\n    if (activeOtherPlayers == 0) return false; // No other players and have more than 10, don't draw\n\n    // Default probability based on bot's current total\n    let drawProbability;\n\n    // Check if any holding players are likely ahead\n    const holdingPlayersAhead = otherPlayers.some(playerData => {\n      if (playerData.status !== 'holding') return false;\n\n      // Calculate visible total - for human player exclude first card, for bots include all visible cards\n      const visibleTotal = playerData.isHuman ? cardUtils.calculateTotal(playerData.visibleCards.slice(1)) : cardUtils.calculateTotal(playerData.visibleCards);\n\n      // Consider a player ahead if their visible cards suggest they're close to 17\n      // (remember we can't see their hidden card)\n      return visibleTotal >= botTotal;\n    });\n    if (holdingPlayersAhead) {\n      drawProbability = 1; // Definetely draw\n    }\n\n    // Count holding players directly with filter\n    const holdingPlayersCount = otherPlayers.filter(player => player.status === 'holding').length;\n\n    // Factor in both holding and active players\n    const holdingFactor = 0.1 * holdingPlayersCount;\n    const activeFactor = 0.05 * activeOtherPlayers; // Adjust the weight as needed\n\n    switch (botTotal) {\n      case 11:\n        drawProbability = 0.5 + holdingFactor + activeFactor;\n        break;\n      case 12:\n        drawProbability = 0.4 + holdingFactor + activeFactor;\n        break;\n      case 13:\n        drawProbability = 0.2 + holdingFactor + activeFactor;\n        break;\n      case 14:\n        drawProbability = 0.1 + holdingFactor + activeFactor;\n        break;\n      case 15:\n        drawProbability = 0.05 + holdingFactor + activeFactor;\n        break;\n      case 16:\n        drawProbability = 0.05 + holdingFactor;\n        break;\n      default:\n        drawProbability = 0;\n    }\n\n    // Adjust strategy based on number of opponents\n    if (activeOtherPlayers <= 1) {\n      // More conservative with fewer opponents\n      drawProbability *= 0.8;\n    }\n\n    // Ensure probability is within bounds\n    drawProbability = Math.max(0, Math.min(1, drawProbability));\n    return Math.random() < 1;\n  };\n  const processBotTurn = useCallback(() => {\n    const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n\n    // Get data from all other players\n    const otherPlayersData = gameState.players.filter((player, index) => index !== gameState.currentPlayerIndex);\n\n    // Bot decision based on visible information\n    let updatedGameState;\n    if (shouldBotDraw(currentPlayer.cards, otherPlayersData)) {\n      updatedGameState = handleDrawCard(gameState, currentPlayer, gameState.currentPlayerIndex);\n    } else {\n      updatedGameState = handleHold(gameState, currentPlayer, gameState.currentPlayerIndex);\n    }\n    setGameState(updatedGameState);\n  }, [gameState, setGameState]);\n  return {\n    processBotTurn\n  };\n}\n_s(useBotAI, \"ph+a3mvihLl3fb35JehTA4aTodg=\");","map":{"version":3,"names":["useCallback","cardUtils","handleDrawCard","handleHold","useBotAI","gameState","setGameState","_s","shouldBotDraw","botCards","otherPlayers","botTotal","calculateTotal","activeOtherPlayers","filter","p","status","length","drawProbability","holdingPlayersAhead","some","playerData","visibleTotal","isHuman","visibleCards","slice","holdingPlayersCount","player","holdingFactor","activeFactor","Math","max","min","random","processBotTurn","currentPlayer","players","currentPlayerIndex","otherPlayersData","index","updatedGameState","cards"],"sources":["/Users/pradipbade/Documents/Projects/Small Projects/react-3d-card-game/src/games/gameOf17/useBotAI.js"],"sourcesContent":["import { useCallback } from 'react';\nimport { cardUtils } from '../../services/cardUtils'; // Update path\nimport { handleDrawCard, handleHold } from './gameLogic';\nexport default function useBotAI(gameState, setGameState) {\n    // Game of 17 specific bot decision-making logic\n    const shouldBotDraw = (botCards, otherPlayers) => {\n        const botTotal = cardUtils.calculateTotal(botCards);\n\n        // Base probabilities - never draw if at or over 17\n        if (botTotal >= 17) return false;\n\n        // Must draw if under 11 (game rule)\n        if (botTotal < 11) return true;\n\n        // Count number of other players still in the game\n        const activeOtherPlayers = otherPlayers.filter(p => p.status !== 'eliminated').length;\n        if (activeOtherPlayers == 0) return false;  // No other players and have more than 10, don't draw\n\n        // Default probability based on bot's current total\n        let drawProbability;\n\n\n        // Check if any holding players are likely ahead\n        const holdingPlayersAhead = otherPlayers.some(playerData => {\n            if (playerData.status !== 'holding') return false;\n\n            // Calculate visible total - for human player exclude first card, for bots include all visible cards\n            const visibleTotal = playerData.isHuman\n                ? cardUtils.calculateTotal(playerData.visibleCards.slice(1))\n                : cardUtils.calculateTotal(playerData.visibleCards);\n\n            // Consider a player ahead if their visible cards suggest they're close to 17\n            // (remember we can't see their hidden card)\n            return visibleTotal >= botTotal;\n        });\n\n        if (holdingPlayersAhead) {\n            drawProbability = 1; // Definetely draw\n        }\n\n        // Count holding players directly with filter\n        const holdingPlayersCount = otherPlayers.filter(player => player.status === 'holding').length;\n\n        // Factor in both holding and active players\n        const holdingFactor = 0.1 * holdingPlayersCount;\n        const activeFactor = 0.05 * activeOtherPlayers; // Adjust the weight as needed\n\n        switch (botTotal) {\n            case 11:\n                drawProbability = 0.5 + holdingFactor + activeFactor; break;\n            case 12:\n                drawProbability = 0.4 + holdingFactor + activeFactor; break;\n            case 13:\n                drawProbability = 0.2 + holdingFactor + activeFactor; break;\n            case 14:\n                drawProbability = 0.1 + holdingFactor + activeFactor; break;\n            case 15:\n                drawProbability = 0.05 + holdingFactor + activeFactor; break;\n            case 16:\n                drawProbability = 0.05 + holdingFactor; break;\n            default:\n                drawProbability = 0;           \n        }\n        \n\n\n        // Adjust strategy based on number of opponents\n        if (activeOtherPlayers <= 1) {\n            // More conservative with fewer opponents\n            drawProbability *= 0.8;\n        }\n\n\n\n        // Ensure probability is within bounds\n        drawProbability = Math.max(0, Math.min(1, drawProbability));\n\n        return Math.random() < 1;\n    };\n\n    const processBotTurn = useCallback(() => {\n        const currentPlayer = gameState.players[gameState.currentPlayerIndex];\n\n        // Get data from all other players\n        const otherPlayersData = gameState.players\n            .filter((player, index) => index !== gameState.currentPlayerIndex);\n\n        // Bot decision based on visible information\n        let updatedGameState;\n\n        if (shouldBotDraw(currentPlayer.cards, otherPlayersData)) {\n            updatedGameState = handleDrawCard(gameState, currentPlayer, gameState.currentPlayerIndex);\n        } else {\n            updatedGameState = handleHold(gameState, currentPlayer, gameState.currentPlayerIndex);\n        }\n\n        setGameState(updatedGameState);\n    }, [gameState, setGameState]);\n\n    return { processBotTurn };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}