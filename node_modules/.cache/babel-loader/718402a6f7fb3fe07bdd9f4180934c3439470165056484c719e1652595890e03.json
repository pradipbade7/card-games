{"ast":null,"code":"import { cardUtils } from '../../services/cardUtils';\n\n/**\n * Set up a new game with the specified number of players\n * @param {number} numPlayers - Number of players (including human)\n * @param {string} cardBackStyle - Style of card backs to use\n * @return {Object} Initial game state\n */\nexport function setupInitialGame(numPlayers, cardBackStyle = 'cardback') {\n  let deck = cardUtils.shuffle(cardUtils.generateDeck());\n  const players = [];\n  const initialLog = ['Game started!'];\n  for (let i = 0; i < numPlayers; i++) {\n    const playerName = i === 0 ? 'You' : `Bot ${i}`;\n    const {\n      drawn,\n      remaining\n    } = cardUtils.drawCards(deck, 1);\n    const drawnCard = drawn[0];\n    deck = remaining;\n    const player = {\n      id: i,\n      name: playerName,\n      isHuman: i === 0,\n      cards: [...drawn],\n      hiddenCards: i === 0 ? [] : [...drawn],\n      // Initial card is hidden for bots\n      visibleCards: i === 0 ? [...drawn] : [],\n      // Initial card is visible for human\n      total: cardUtils.calculateTotal(drawn),\n      status: 'active',\n      // active, holding, eliminated, winner\n      turnState: 'idle' // idle, thinking, acted\n    };\n    players.push(player);\n    if (i === 0) {\n      initialLog.push(`You drew ${cardUtils.getCardName(drawnCard)}. Total: ${player.total}`);\n    } else {\n      initialLog.push(`${playerName} drew a card.`);\n    }\n  }\n  initialLog.push(\"Your turn.\");\n  return {\n    phase: 'playing',\n    players,\n    deck,\n    currentPlayerIndex: 0,\n    winner: null,\n    gameLog: initialLog,\n    gameId: Date.now(),\n    cardBackStyle,\n    aiActionInProgress: false\n  };\n}\n\n/**\n * Handle a player drawing a card from the deck\n * @param {Object} gameState - Current game state\n * @param {Object} player - Player drawing a card\n * @param {number} playerIndex - Index of player in gameState.players array\n * @return {Object} Updated game state\n */\nexport function handleDrawCard(gameState, player, playerIndex) {\n  if (gameState.phase !== 'playing' || player.status !== 'active') {\n    return gameState; // Can't draw if game is over or player isn't active\n  }\n  const updatedPlayers = [...gameState.players];\n  const {\n    drawn,\n    remaining\n  } = cardUtils.drawCards(gameState.deck, 1);\n  const drawnCard = drawn[0];\n  const newTotal = player.total + cardUtils.getCardValue(drawnCard);\n\n  // Update log messages\n  const updatedLog = [...gameState.gameLog];\n  if (player.isHuman) {\n    updatedLog.push(`You drew ${cardUtils.getCardName(drawnCard)}. Total: ${newTotal}`);\n  } else {\n    updatedLog.push(`${player.name} drew ${cardUtils.getCardName(drawnCard)}. Total: ${newTotal}`);\n  }\n\n  // Determine if player is eliminated (bust)\n  const isEliminated = newTotal > 17;\n\n  // Update player's cards and status\n  updatedPlayers[playerIndex] = {\n    ...player,\n    cards: [...player.cards, drawnCard],\n    visibleCards: [...player.visibleCards, drawnCard],\n    // Add drawn card to visible cards\n    total: newTotal,\n    status: isEliminated ? 'eliminated' : 'active',\n    turnState: player.isHuman ? 'idle' : 'acted' // Mark AI as having acted\n  };\n  if (isEliminated) {\n    updatedLog.push(`${player.isHuman ? 'You' : player.name} went over 17 and is eliminated!`);\n  }\n\n  // Check for instant win (exactly 17)\n  if (newTotal === 17) {\n    updatedPlayers[playerIndex] = {\n      ...updatedPlayers[playerIndex],\n      status: 'winner'\n    };\n    updatedLog.push(`${player.isHuman ? 'You' : player.name} got exactly 17 - an instant win!`);\n    return {\n      ...gameState,\n      phase: 'gameOver',\n      players: updatedPlayers,\n      deck: remaining,\n      winner: playerIndex,\n      gameLog: updatedLog,\n      aiActionInProgress: false\n    };\n  }\n\n  // If it's a human player or an AI that's eliminated, move to next player\n  let nextPlayerIndex = playerIndex;\n  let aiActionInProgress = false;\n  if (player.isHuman || isEliminated) {\n    nextPlayerIndex = findNextActivePlayerIndex(updatedPlayers, playerIndex);\n    if (nextPlayerIndex === -1) {\n      // No active players left, game is over\n      return checkGameEnd({\n        ...gameState,\n        phase: 'revealing',\n        players: updatedPlayers,\n        deck: remaining,\n        gameLog: [...updatedLog, \"All players have finished. Revealing results...\"],\n        aiActionInProgress: false\n      });\n    } else {\n      const nextPlayer = updatedPlayers[nextPlayerIndex];\n      updatedLog.push(`${nextPlayer.isHuman ? 'Your' : nextPlayer.name + \"'s\"} turn.`);\n\n      // If next player is AI, mark that we need to process their turn\n      aiActionInProgress = !nextPlayer.isHuman;\n\n      // If the next player is an AI, mark them as \"thinking\"\n      if (!nextPlayer.isHuman) {\n        updatedPlayers[nextPlayerIndex] = {\n          ...nextPlayer,\n          turnState: 'thinking'\n        };\n      }\n    }\n  }\n  return {\n    ...gameState,\n    players: updatedPlayers,\n    deck: remaining,\n    currentPlayerIndex: nextPlayerIndex,\n    gameLog: updatedLog,\n    aiActionInProgress\n  };\n}\n\n/**\n * Handle a player holding their current total\n * @param {Object} gameState - Current game state\n * @param {Object} player - Player holding\n * @param {number} playerIndex - Index of player in gameState.players array\n * @return {Object} Updated game state\n */\nexport function handleHold(gameState, player, playerIndex) {\n  if (gameState.phase !== 'playing' || player.status !== 'active') {\n    return gameState; // Can't hold if game is over or player isn't active\n  }\n  if (player.total < 11) {\n    return gameState; // Can't hold below 11\n  }\n  const updatedPlayers = [...gameState.players];\n  const updatedLog = [...gameState.gameLog];\n\n  // Update player status to holding\n  updatedPlayers[playerIndex] = {\n    ...player,\n    status: 'holding',\n    turnState: player.isHuman ? 'idle' : 'acted' // Mark AI as having acted\n  };\n  updatedLog.push(`${player.isHuman ? 'You' : player.name} holds at ${player.total}.`);\n\n  // Move to next player\n  const nextPlayerIndex = findNextActivePlayerIndex(updatedPlayers, playerIndex);\n  let aiActionInProgress = false;\n  if (nextPlayerIndex === -1) {\n    // No active players left, move to revealing phase\n    return checkGameEnd({\n      ...gameState,\n      phase: 'revealing',\n      players: updatedPlayers,\n      gameLog: [...updatedLog, \"All players have finished. Revealing results...\"],\n      aiActionInProgress: false\n    });\n  }\n  const nextPlayer = updatedPlayers[nextPlayerIndex];\n  updatedLog.push(`${nextPlayer.isHuman ? 'Your' : nextPlayer.name + \"'s\"} turn.`);\n\n  // If next player is AI, mark that we need to process their turn\n  aiActionInProgress = !nextPlayer.isHuman;\n\n  // If the next player is an AI, mark them as \"thinking\"\n  if (!nextPlayer.isHuman) {\n    updatedPlayers[nextPlayerIndex] = {\n      ...nextPlayer,\n      turnState: 'thinking'\n    };\n  }\n  return {\n    ...gameState,\n    players: updatedPlayers,\n    currentPlayerIndex: nextPlayerIndex,\n    gameLog: updatedLog,\n    aiActionInProgress\n  };\n}\n\n/**\n * Find the index of the next active player\n * @param {Array} players - List of players\n * @param {number} currentIndex - Current player index\n * @return {number} Index of next active player, or -1 if none found\n */\nfunction findNextActivePlayerIndex(players, currentIndex) {\n  for (let i = 1; i <= players.length; i++) {\n    const nextIndex = (currentIndex + i) % players.length;\n    if (players[nextIndex].status === 'active') {\n      return nextIndex;\n    }\n  }\n  return -1; // No active players found\n}\n\n/**\n * Check if the game has ended and determine winner\n * @param {Object} gameState - Current game state\n * @return {Object} Updated game state with winner determined\n */\nexport function checkGameEnd(gameState) {\n  // Only proceed if we're in revealing phase or no active players remain\n  const hasActivePlayer = gameState.players.some(p => p.status === 'active');\n  if (gameState.phase !== 'revealing' && hasActivePlayer) {\n    return gameState;\n  }\n  const updatedPlayers = [...gameState.players];\n  const updatedLog = [...gameState.gameLog];\n\n  // Check if someone already won with exactly 17\n  const exactWinner = updatedPlayers.findIndex(p => p.total === 17);\n  if (exactWinner >= 0) {\n    updatedPlayers[exactWinner] = {\n      ...updatedPlayers[exactWinner],\n      status: 'winner'\n    };\n    updatedLog.push(`${updatedPlayers[exactWinner].isHuman ? 'You' : updatedPlayers[exactWinner].name} wins with a perfect score of 17!`);\n    return {\n      ...gameState,\n      phase: 'gameOver',\n      players: updatedPlayers,\n      winner: exactWinner,\n      gameLog: updatedLog,\n      aiActionInProgress: false\n    };\n  }\n\n  // Find eligible players (not eliminated)\n  const eligiblePlayers = updatedPlayers.filter(p => p.total <= 17);\n  if (eligiblePlayers.length === 0) {\n    updatedLog.push('No winner! All players went over 17.');\n    return {\n      ...gameState,\n      phase: 'gameOver',\n      players: updatedPlayers,\n      winner: null,\n      gameLog: updatedLog,\n      aiActionInProgress: false\n    };\n  }\n\n  // Find player with highest score\n  let highestScore = 0;\n  let winningPlayer = -1;\n  eligiblePlayers.forEach(player => {\n    if (player.total > highestScore) {\n      highestScore = player.total;\n      winningPlayer = player.id;\n    }\n  });\n\n  // Check for ties\n  const tiedPlayers = eligiblePlayers.filter(p => p.total === highestScore);\n  if (tiedPlayers.length > 1) {\n    const tiedNames = tiedPlayers.map(p => p.isHuman ? 'You' : p.name).join(' and ');\n    updatedLog.push(`Tie game! ${tiedNames} tied with ${highestScore} points.`);\n\n    // Mark all tied players as winners\n    tiedPlayers.forEach(player => {\n      updatedPlayers[player.id] = {\n        ...updatedPlayers[player.id],\n        status: 'winner'\n      };\n    });\n\n    // Use the first tied player as the \"primary\" winner\n    winningPlayer = tiedPlayers[0].id;\n  } else if (winningPlayer !== -1) {\n    updatedLog.push(`${updatedPlayers[winningPlayer].isHuman ? 'You' : updatedPlayers[winningPlayer].name} wins with a score of ${highestScore}!`);\n    updatedPlayers[winningPlayer] = {\n      ...updatedPlayers[winningPlayer],\n      status: 'winner'\n    };\n  }\n  return {\n    ...gameState,\n    phase: 'gameOver',\n    players: updatedPlayers,\n    winner: winningPlayer,\n    gameLog: updatedLog,\n    aiActionInProgress: false\n  };\n}\n\n/**\n * Handle AI player's turn\n * @param {Object} gameState - Current game state\n * @return {Object} Updated game state after AI's turn\n */\nexport function handleAITurn(gameState) {\n  if (gameState.phase !== 'playing') {\n    return gameState;\n  }\n  const playerIndex = gameState.currentPlayerIndex;\n  const player = gameState.players[playerIndex];\n\n  // Only handle if it's an AI player and they are active\n  if (player.isHuman || player.status !== 'active') {\n    return {\n      ...gameState,\n      aiActionInProgress: false\n    };\n  }\n\n  // AI strategy: Always draw if below 11 (required)\n  // If 11-13, draw with 70% probability\n  // If 14-15, draw with 40% probability\n  // If 16-17, draw with 10% probability\n\n  if (player.total < 11) {\n    // Must draw if below 11\n    return handleDrawCard(gameState, player, playerIndex);\n  } else {\n    // Decision based on current total\n    let drawProbability;\n    if (player.total <= 13) {\n      drawProbability = 0.7;\n    } else if (player.total <= 15) {\n      drawProbability = 0.4;\n    } else {\n      drawProbability = 0.1;\n    }\n\n    // Make decision\n    if (Math.random() < drawProbability) {\n      return handleDrawCard(gameState, player, playerIndex);\n    } else {\n      return handleHold(gameState, player, playerIndex);\n    }\n  }\n}","map":{"version":3,"names":["cardUtils","setupInitialGame","numPlayers","cardBackStyle","deck","shuffle","generateDeck","players","initialLog","i","playerName","drawn","remaining","drawCards","drawnCard","player","id","name","isHuman","cards","hiddenCards","visibleCards","total","calculateTotal","status","turnState","push","getCardName","phase","currentPlayerIndex","winner","gameLog","gameId","Date","now","aiActionInProgress","handleDrawCard","gameState","playerIndex","updatedPlayers","newTotal","getCardValue","updatedLog","isEliminated","nextPlayerIndex","findNextActivePlayerIndex","checkGameEnd","nextPlayer","handleHold","currentIndex","length","nextIndex","hasActivePlayer","some","p","exactWinner","findIndex","eligiblePlayers","filter","highestScore","winningPlayer","forEach","tiedPlayers","tiedNames","map","join","handleAITurn","drawProbability","Math","random"],"sources":["/Users/pradipbade/Documents/Projects/Small Projects/react-3d-card-game/src/games/gameOf17/gameLogic.js"],"sourcesContent":["import { cardUtils } from '../../services/cardUtils';\n\n/**\n * Set up a new game with the specified number of players\n * @param {number} numPlayers - Number of players (including human)\n * @param {string} cardBackStyle - Style of card backs to use\n * @return {Object} Initial game state\n */\nexport function setupInitialGame(numPlayers, cardBackStyle = 'cardback') {\n    let deck = cardUtils.shuffle(cardUtils.generateDeck());\n    const players = [];\n    const initialLog = ['Game started!'];\n\n    for (let i = 0; i < numPlayers; i++) {\n        const playerName = i === 0 ? 'You' : `Bot ${i}`;\n        const { drawn, remaining } = cardUtils.drawCards(deck, 1);\n        const drawnCard = drawn[0];\n        deck = remaining;\n\n        const player = {\n            id: i,\n            name: playerName,\n            isHuman: i === 0,\n            cards: [...drawn],\n            hiddenCards: i === 0 ? [] : [...drawn], // Initial card is hidden for bots\n            visibleCards: i === 0 ? [...drawn] : [], // Initial card is visible for human\n            total: cardUtils.calculateTotal(drawn),\n            status: 'active', // active, holding, eliminated, winner\n            turnState: 'idle' // idle, thinking, acted\n        };\n\n        players.push(player);\n\n        if (i === 0) {\n            initialLog.push(`You drew ${cardUtils.getCardName(drawnCard)}. Total: ${player.total}`);\n        } else {\n            initialLog.push(`${playerName} drew a card.`);\n        }\n    }\n\n    initialLog.push(\"Your turn.\");\n\n    return {\n        phase: 'playing',\n        players,\n        deck,\n        currentPlayerIndex: 0,\n        winner: null,\n        gameLog: initialLog,\n        gameId: Date.now(),\n        cardBackStyle,\n        aiActionInProgress: false\n    };\n}\n\n/**\n * Handle a player drawing a card from the deck\n * @param {Object} gameState - Current game state\n * @param {Object} player - Player drawing a card\n * @param {number} playerIndex - Index of player in gameState.players array\n * @return {Object} Updated game state\n */\nexport function handleDrawCard(gameState, player, playerIndex) {\n    if (gameState.phase !== 'playing' || player.status !== 'active') {\n        return gameState; // Can't draw if game is over or player isn't active\n    }\n    \n    const updatedPlayers = [...gameState.players];\n    const { drawn, remaining } = cardUtils.drawCards(gameState.deck, 1);\n    const drawnCard = drawn[0];\n    const newTotal = player.total + cardUtils.getCardValue(drawnCard);\n    \n    // Update log messages\n    const updatedLog = [...gameState.gameLog];\n    if (player.isHuman) {\n        updatedLog.push(`You drew ${cardUtils.getCardName(drawnCard)}. Total: ${newTotal}`);\n    } else {\n        updatedLog.push(`${player.name} drew ${cardUtils.getCardName(drawnCard)}. Total: ${newTotal}`);\n    }\n    \n    // Determine if player is eliminated (bust)\n    const isEliminated = newTotal > 17;\n    \n    // Update player's cards and status\n    updatedPlayers[playerIndex] = {\n        ...player,\n        cards: [...player.cards, drawnCard],\n        visibleCards: [...player.visibleCards, drawnCard], // Add drawn card to visible cards\n        total: newTotal,\n        status: isEliminated ? 'eliminated' : 'active',\n        turnState: player.isHuman ? 'idle' : 'acted' // Mark AI as having acted\n    };\n    \n    if (isEliminated) {\n        updatedLog.push(`${player.isHuman ? 'You' : player.name} went over 17 and is eliminated!`);\n    }\n    \n    // Check for instant win (exactly 17)\n    if (newTotal === 17) {\n        updatedPlayers[playerIndex] = {\n            ...updatedPlayers[playerIndex],\n            status: 'winner'\n        };\n        \n        updatedLog.push(`${player.isHuman ? 'You' : player.name} got exactly 17 - an instant win!`);\n        \n        return {\n            ...gameState,\n            phase: 'gameOver',\n            players: updatedPlayers,\n            deck: remaining,\n            winner: playerIndex,\n            gameLog: updatedLog,\n            aiActionInProgress: false\n        };\n    }\n    \n    // If it's a human player or an AI that's eliminated, move to next player\n    let nextPlayerIndex = playerIndex;\n    let aiActionInProgress = false;\n    \n    if (player.isHuman || isEliminated) {\n        nextPlayerIndex = findNextActivePlayerIndex(updatedPlayers, playerIndex);\n        \n        if (nextPlayerIndex === -1) {\n            // No active players left, game is over\n            return checkGameEnd({\n                ...gameState,\n                phase: 'revealing',\n                players: updatedPlayers,\n                deck: remaining,\n                gameLog: [...updatedLog, \"All players have finished. Revealing results...\"],\n                aiActionInProgress: false\n            });\n        } else {\n            const nextPlayer = updatedPlayers[nextPlayerIndex];\n            updatedLog.push(`${nextPlayer.isHuman ? 'Your' : nextPlayer.name + \"'s\"} turn.`);\n            \n            // If next player is AI, mark that we need to process their turn\n            aiActionInProgress = !nextPlayer.isHuman;\n            \n            // If the next player is an AI, mark them as \"thinking\"\n            if (!nextPlayer.isHuman) {\n                updatedPlayers[nextPlayerIndex] = {\n                    ...nextPlayer,\n                    turnState: 'thinking'\n                };\n            }\n        }\n    }\n    \n    return {\n        ...gameState,\n        players: updatedPlayers,\n        deck: remaining,\n        currentPlayerIndex: nextPlayerIndex,\n        gameLog: updatedLog,\n        aiActionInProgress\n    };\n}\n\n/**\n * Handle a player holding their current total\n * @param {Object} gameState - Current game state\n * @param {Object} player - Player holding\n * @param {number} playerIndex - Index of player in gameState.players array\n * @return {Object} Updated game state\n */\nexport function handleHold(gameState, player, playerIndex) {\n    if (gameState.phase !== 'playing' || player.status !== 'active') {\n        return gameState; // Can't hold if game is over or player isn't active\n    }\n    \n    if (player.total < 11) {\n        return gameState; // Can't hold below 11\n    }\n    \n    const updatedPlayers = [...gameState.players];\n    const updatedLog = [...gameState.gameLog];\n    \n    // Update player status to holding\n    updatedPlayers[playerIndex] = {\n        ...player,\n        status: 'holding',\n        turnState: player.isHuman ? 'idle' : 'acted' // Mark AI as having acted\n    };\n    \n    updatedLog.push(`${player.isHuman ? 'You' : player.name} holds at ${player.total}.`);\n    \n    // Move to next player\n    const nextPlayerIndex = findNextActivePlayerIndex(updatedPlayers, playerIndex);\n    let aiActionInProgress = false;\n    \n    if (nextPlayerIndex === -1) {\n        // No active players left, move to revealing phase\n        return checkGameEnd({\n            ...gameState,\n            phase: 'revealing',\n            players: updatedPlayers,\n            gameLog: [...updatedLog, \"All players have finished. Revealing results...\"],\n            aiActionInProgress: false\n        });\n    }\n    \n    const nextPlayer = updatedPlayers[nextPlayerIndex];\n    updatedLog.push(`${nextPlayer.isHuman ? 'Your' : nextPlayer.name + \"'s\"} turn.`);\n    \n    // If next player is AI, mark that we need to process their turn\n    aiActionInProgress = !nextPlayer.isHuman;\n    \n    // If the next player is an AI, mark them as \"thinking\"\n    if (!nextPlayer.isHuman) {\n        updatedPlayers[nextPlayerIndex] = {\n            ...nextPlayer,\n            turnState: 'thinking'\n        };\n    }\n    \n    return {\n        ...gameState,\n        players: updatedPlayers,\n        currentPlayerIndex: nextPlayerIndex,\n        gameLog: updatedLog,\n        aiActionInProgress\n    };\n}\n\n/**\n * Find the index of the next active player\n * @param {Array} players - List of players\n * @param {number} currentIndex - Current player index\n * @return {number} Index of next active player, or -1 if none found\n */\nfunction findNextActivePlayerIndex(players, currentIndex) {\n    for (let i = 1; i <= players.length; i++) {\n        const nextIndex = (currentIndex + i) % players.length;\n        if (players[nextIndex].status === 'active') {\n            return nextIndex;\n        }\n    }\n    return -1; // No active players found\n}\n\n/**\n * Check if the game has ended and determine winner\n * @param {Object} gameState - Current game state\n * @return {Object} Updated game state with winner determined\n */\nexport function checkGameEnd(gameState) {\n    // Only proceed if we're in revealing phase or no active players remain\n    const hasActivePlayer = gameState.players.some(p => p.status === 'active');\n    \n    if (gameState.phase !== 'revealing' && hasActivePlayer) {\n        return gameState;\n    }\n    \n    const updatedPlayers = [...gameState.players];\n    const updatedLog = [...gameState.gameLog];\n    \n    // Check if someone already won with exactly 17\n    const exactWinner = updatedPlayers.findIndex(p => p.total === 17);\n    if (exactWinner >= 0) {\n        updatedPlayers[exactWinner] = {\n            ...updatedPlayers[exactWinner],\n            status: 'winner'\n        };\n        \n        updatedLog.push(`${updatedPlayers[exactWinner].isHuman ? 'You' : updatedPlayers[exactWinner].name} wins with a perfect score of 17!`);\n        \n        return {\n            ...gameState,\n            phase: 'gameOver',\n            players: updatedPlayers,\n            winner: exactWinner,\n            gameLog: updatedLog,\n            aiActionInProgress: false\n        };\n    }\n    \n    // Find eligible players (not eliminated)\n    const eligiblePlayers = updatedPlayers.filter(p => p.total <= 17);\n    \n    if (eligiblePlayers.length === 0) {\n        updatedLog.push('No winner! All players went over 17.');\n        \n        return {\n            ...gameState,\n            phase: 'gameOver',\n            players: updatedPlayers,\n            winner: null,\n            gameLog: updatedLog,\n            aiActionInProgress: false\n        };\n    }\n    \n    // Find player with highest score\n    let highestScore = 0;\n    let winningPlayer = -1;\n    \n    eligiblePlayers.forEach(player => {\n        if (player.total > highestScore) {\n            highestScore = player.total;\n            winningPlayer = player.id;\n        }\n    });\n    \n    // Check for ties\n    const tiedPlayers = eligiblePlayers.filter(p => p.total === highestScore);\n    \n    if (tiedPlayers.length > 1) {\n        const tiedNames = tiedPlayers.map(p => p.isHuman ? 'You' : p.name).join(' and ');\n        updatedLog.push(`Tie game! ${tiedNames} tied with ${highestScore} points.`);\n        \n        // Mark all tied players as winners\n        tiedPlayers.forEach(player => {\n            updatedPlayers[player.id] = {\n                ...updatedPlayers[player.id],\n                status: 'winner'\n            };\n        });\n        \n        // Use the first tied player as the \"primary\" winner\n        winningPlayer = tiedPlayers[0].id;\n    } else if (winningPlayer !== -1) {\n        updatedLog.push(`${updatedPlayers[winningPlayer].isHuman ? 'You' : updatedPlayers[winningPlayer].name} wins with a score of ${highestScore}!`);\n        \n        updatedPlayers[winningPlayer] = {\n            ...updatedPlayers[winningPlayer],\n            status: 'winner'\n        };\n    }\n    \n    return {\n        ...gameState,\n        phase: 'gameOver',\n        players: updatedPlayers,\n        winner: winningPlayer,\n        gameLog: updatedLog,\n        aiActionInProgress: false\n    };\n}\n\n/**\n * Handle AI player's turn\n * @param {Object} gameState - Current game state\n * @return {Object} Updated game state after AI's turn\n */\nexport function handleAITurn(gameState) {\n    if (gameState.phase !== 'playing') {\n        return gameState;\n    }\n    \n    const playerIndex = gameState.currentPlayerIndex;\n    const player = gameState.players[playerIndex];\n    \n    // Only handle if it's an AI player and they are active\n    if (player.isHuman || player.status !== 'active') {\n        return {\n            ...gameState,\n            aiActionInProgress: false\n        };\n    }\n    \n    // AI strategy: Always draw if below 11 (required)\n    // If 11-13, draw with 70% probability\n    // If 14-15, draw with 40% probability\n    // If 16-17, draw with 10% probability\n    \n    if (player.total < 11) {\n        // Must draw if below 11\n        return handleDrawCard(gameState, player, playerIndex);\n    } else {\n        // Decision based on current total\n        let drawProbability;\n        if (player.total <= 13) {\n            drawProbability = 0.7;\n        } else if (player.total <= 15) {\n            drawProbability = 0.4;\n        } else {\n            drawProbability = 0.1;\n        }\n        \n        // Make decision\n        if (Math.random() < drawProbability) {\n            return handleDrawCard(gameState, player, playerIndex);\n        } else {\n            return handleHold(gameState, player, playerIndex);\n        }\n    }\n}"],"mappings":"AAAA,SAASA,SAAS,QAAQ,0BAA0B;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,gBAAgBA,CAACC,UAAU,EAAEC,aAAa,GAAG,UAAU,EAAE;EACrE,IAAIC,IAAI,GAAGJ,SAAS,CAACK,OAAO,CAACL,SAAS,CAACM,YAAY,CAAC,CAAC,CAAC;EACtD,MAAMC,OAAO,GAAG,EAAE;EAClB,MAAMC,UAAU,GAAG,CAAC,eAAe,CAAC;EAEpC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,UAAU,EAAEO,CAAC,EAAE,EAAE;IACjC,MAAMC,UAAU,GAAGD,CAAC,KAAK,CAAC,GAAG,KAAK,GAAG,OAAOA,CAAC,EAAE;IAC/C,MAAM;MAAEE,KAAK;MAAEC;IAAU,CAAC,GAAGZ,SAAS,CAACa,SAAS,CAACT,IAAI,EAAE,CAAC,CAAC;IACzD,MAAMU,SAAS,GAAGH,KAAK,CAAC,CAAC,CAAC;IAC1BP,IAAI,GAAGQ,SAAS;IAEhB,MAAMG,MAAM,GAAG;MACXC,EAAE,EAAEP,CAAC;MACLQ,IAAI,EAAEP,UAAU;MAChBQ,OAAO,EAAET,CAAC,KAAK,CAAC;MAChBU,KAAK,EAAE,CAAC,GAAGR,KAAK,CAAC;MACjBS,WAAW,EAAEX,CAAC,KAAK,CAAC,GAAG,EAAE,GAAG,CAAC,GAAGE,KAAK,CAAC;MAAE;MACxCU,YAAY,EAAEZ,CAAC,KAAK,CAAC,GAAG,CAAC,GAAGE,KAAK,CAAC,GAAG,EAAE;MAAE;MACzCW,KAAK,EAAEtB,SAAS,CAACuB,cAAc,CAACZ,KAAK,CAAC;MACtCa,MAAM,EAAE,QAAQ;MAAE;MAClBC,SAAS,EAAE,MAAM,CAAC;IACtB,CAAC;IAEDlB,OAAO,CAACmB,IAAI,CAACX,MAAM,CAAC;IAEpB,IAAIN,CAAC,KAAK,CAAC,EAAE;MACTD,UAAU,CAACkB,IAAI,CAAC,YAAY1B,SAAS,CAAC2B,WAAW,CAACb,SAAS,CAAC,YAAYC,MAAM,CAACO,KAAK,EAAE,CAAC;IAC3F,CAAC,MAAM;MACHd,UAAU,CAACkB,IAAI,CAAC,GAAGhB,UAAU,eAAe,CAAC;IACjD;EACJ;EAEAF,UAAU,CAACkB,IAAI,CAAC,YAAY,CAAC;EAE7B,OAAO;IACHE,KAAK,EAAE,SAAS;IAChBrB,OAAO;IACPH,IAAI;IACJyB,kBAAkB,EAAE,CAAC;IACrBC,MAAM,EAAE,IAAI;IACZC,OAAO,EAAEvB,UAAU;IACnBwB,MAAM,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC;IAClB/B,aAAa;IACbgC,kBAAkB,EAAE;EACxB,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,cAAcA,CAACC,SAAS,EAAEtB,MAAM,EAAEuB,WAAW,EAAE;EAC3D,IAAID,SAAS,CAACT,KAAK,KAAK,SAAS,IAAIb,MAAM,CAACS,MAAM,KAAK,QAAQ,EAAE;IAC7D,OAAOa,SAAS,CAAC,CAAC;EACtB;EAEA,MAAME,cAAc,GAAG,CAAC,GAAGF,SAAS,CAAC9B,OAAO,CAAC;EAC7C,MAAM;IAAEI,KAAK;IAAEC;EAAU,CAAC,GAAGZ,SAAS,CAACa,SAAS,CAACwB,SAAS,CAACjC,IAAI,EAAE,CAAC,CAAC;EACnE,MAAMU,SAAS,GAAGH,KAAK,CAAC,CAAC,CAAC;EAC1B,MAAM6B,QAAQ,GAAGzB,MAAM,CAACO,KAAK,GAAGtB,SAAS,CAACyC,YAAY,CAAC3B,SAAS,CAAC;;EAEjE;EACA,MAAM4B,UAAU,GAAG,CAAC,GAAGL,SAAS,CAACN,OAAO,CAAC;EACzC,IAAIhB,MAAM,CAACG,OAAO,EAAE;IAChBwB,UAAU,CAAChB,IAAI,CAAC,YAAY1B,SAAS,CAAC2B,WAAW,CAACb,SAAS,CAAC,YAAY0B,QAAQ,EAAE,CAAC;EACvF,CAAC,MAAM;IACHE,UAAU,CAAChB,IAAI,CAAC,GAAGX,MAAM,CAACE,IAAI,SAASjB,SAAS,CAAC2B,WAAW,CAACb,SAAS,CAAC,YAAY0B,QAAQ,EAAE,CAAC;EAClG;;EAEA;EACA,MAAMG,YAAY,GAAGH,QAAQ,GAAG,EAAE;;EAElC;EACAD,cAAc,CAACD,WAAW,CAAC,GAAG;IAC1B,GAAGvB,MAAM;IACTI,KAAK,EAAE,CAAC,GAAGJ,MAAM,CAACI,KAAK,EAAEL,SAAS,CAAC;IACnCO,YAAY,EAAE,CAAC,GAAGN,MAAM,CAACM,YAAY,EAAEP,SAAS,CAAC;IAAE;IACnDQ,KAAK,EAAEkB,QAAQ;IACfhB,MAAM,EAAEmB,YAAY,GAAG,YAAY,GAAG,QAAQ;IAC9ClB,SAAS,EAAEV,MAAM,CAACG,OAAO,GAAG,MAAM,GAAG,OAAO,CAAC;EACjD,CAAC;EAED,IAAIyB,YAAY,EAAE;IACdD,UAAU,CAAChB,IAAI,CAAC,GAAGX,MAAM,CAACG,OAAO,GAAG,KAAK,GAAGH,MAAM,CAACE,IAAI,kCAAkC,CAAC;EAC9F;;EAEA;EACA,IAAIuB,QAAQ,KAAK,EAAE,EAAE;IACjBD,cAAc,CAACD,WAAW,CAAC,GAAG;MAC1B,GAAGC,cAAc,CAACD,WAAW,CAAC;MAC9Bd,MAAM,EAAE;IACZ,CAAC;IAEDkB,UAAU,CAAChB,IAAI,CAAC,GAAGX,MAAM,CAACG,OAAO,GAAG,KAAK,GAAGH,MAAM,CAACE,IAAI,mCAAmC,CAAC;IAE3F,OAAO;MACH,GAAGoB,SAAS;MACZT,KAAK,EAAE,UAAU;MACjBrB,OAAO,EAAEgC,cAAc;MACvBnC,IAAI,EAAEQ,SAAS;MACfkB,MAAM,EAAEQ,WAAW;MACnBP,OAAO,EAAEW,UAAU;MACnBP,kBAAkB,EAAE;IACxB,CAAC;EACL;;EAEA;EACA,IAAIS,eAAe,GAAGN,WAAW;EACjC,IAAIH,kBAAkB,GAAG,KAAK;EAE9B,IAAIpB,MAAM,CAACG,OAAO,IAAIyB,YAAY,EAAE;IAChCC,eAAe,GAAGC,yBAAyB,CAACN,cAAc,EAAED,WAAW,CAAC;IAExE,IAAIM,eAAe,KAAK,CAAC,CAAC,EAAE;MACxB;MACA,OAAOE,YAAY,CAAC;QAChB,GAAGT,SAAS;QACZT,KAAK,EAAE,WAAW;QAClBrB,OAAO,EAAEgC,cAAc;QACvBnC,IAAI,EAAEQ,SAAS;QACfmB,OAAO,EAAE,CAAC,GAAGW,UAAU,EAAE,iDAAiD,CAAC;QAC3EP,kBAAkB,EAAE;MACxB,CAAC,CAAC;IACN,CAAC,MAAM;MACH,MAAMY,UAAU,GAAGR,cAAc,CAACK,eAAe,CAAC;MAClDF,UAAU,CAAChB,IAAI,CAAC,GAAGqB,UAAU,CAAC7B,OAAO,GAAG,MAAM,GAAG6B,UAAU,CAAC9B,IAAI,GAAG,IAAI,QAAQ,CAAC;;MAEhF;MACAkB,kBAAkB,GAAG,CAACY,UAAU,CAAC7B,OAAO;;MAExC;MACA,IAAI,CAAC6B,UAAU,CAAC7B,OAAO,EAAE;QACrBqB,cAAc,CAACK,eAAe,CAAC,GAAG;UAC9B,GAAGG,UAAU;UACbtB,SAAS,EAAE;QACf,CAAC;MACL;IACJ;EACJ;EAEA,OAAO;IACH,GAAGY,SAAS;IACZ9B,OAAO,EAAEgC,cAAc;IACvBnC,IAAI,EAAEQ,SAAS;IACfiB,kBAAkB,EAAEe,eAAe;IACnCb,OAAO,EAAEW,UAAU;IACnBP;EACJ,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASa,UAAUA,CAACX,SAAS,EAAEtB,MAAM,EAAEuB,WAAW,EAAE;EACvD,IAAID,SAAS,CAACT,KAAK,KAAK,SAAS,IAAIb,MAAM,CAACS,MAAM,KAAK,QAAQ,EAAE;IAC7D,OAAOa,SAAS,CAAC,CAAC;EACtB;EAEA,IAAItB,MAAM,CAACO,KAAK,GAAG,EAAE,EAAE;IACnB,OAAOe,SAAS,CAAC,CAAC;EACtB;EAEA,MAAME,cAAc,GAAG,CAAC,GAAGF,SAAS,CAAC9B,OAAO,CAAC;EAC7C,MAAMmC,UAAU,GAAG,CAAC,GAAGL,SAAS,CAACN,OAAO,CAAC;;EAEzC;EACAQ,cAAc,CAACD,WAAW,CAAC,GAAG;IAC1B,GAAGvB,MAAM;IACTS,MAAM,EAAE,SAAS;IACjBC,SAAS,EAAEV,MAAM,CAACG,OAAO,GAAG,MAAM,GAAG,OAAO,CAAC;EACjD,CAAC;EAEDwB,UAAU,CAAChB,IAAI,CAAC,GAAGX,MAAM,CAACG,OAAO,GAAG,KAAK,GAAGH,MAAM,CAACE,IAAI,aAAaF,MAAM,CAACO,KAAK,GAAG,CAAC;;EAEpF;EACA,MAAMsB,eAAe,GAAGC,yBAAyB,CAACN,cAAc,EAAED,WAAW,CAAC;EAC9E,IAAIH,kBAAkB,GAAG,KAAK;EAE9B,IAAIS,eAAe,KAAK,CAAC,CAAC,EAAE;IACxB;IACA,OAAOE,YAAY,CAAC;MAChB,GAAGT,SAAS;MACZT,KAAK,EAAE,WAAW;MAClBrB,OAAO,EAAEgC,cAAc;MACvBR,OAAO,EAAE,CAAC,GAAGW,UAAU,EAAE,iDAAiD,CAAC;MAC3EP,kBAAkB,EAAE;IACxB,CAAC,CAAC;EACN;EAEA,MAAMY,UAAU,GAAGR,cAAc,CAACK,eAAe,CAAC;EAClDF,UAAU,CAAChB,IAAI,CAAC,GAAGqB,UAAU,CAAC7B,OAAO,GAAG,MAAM,GAAG6B,UAAU,CAAC9B,IAAI,GAAG,IAAI,QAAQ,CAAC;;EAEhF;EACAkB,kBAAkB,GAAG,CAACY,UAAU,CAAC7B,OAAO;;EAExC;EACA,IAAI,CAAC6B,UAAU,CAAC7B,OAAO,EAAE;IACrBqB,cAAc,CAACK,eAAe,CAAC,GAAG;MAC9B,GAAGG,UAAU;MACbtB,SAAS,EAAE;IACf,CAAC;EACL;EAEA,OAAO;IACH,GAAGY,SAAS;IACZ9B,OAAO,EAAEgC,cAAc;IACvBV,kBAAkB,EAAEe,eAAe;IACnCb,OAAO,EAAEW,UAAU;IACnBP;EACJ,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASU,yBAAyBA,CAACtC,OAAO,EAAE0C,YAAY,EAAE;EACtD,KAAK,IAAIxC,CAAC,GAAG,CAAC,EAAEA,CAAC,IAAIF,OAAO,CAAC2C,MAAM,EAAEzC,CAAC,EAAE,EAAE;IACtC,MAAM0C,SAAS,GAAG,CAACF,YAAY,GAAGxC,CAAC,IAAIF,OAAO,CAAC2C,MAAM;IACrD,IAAI3C,OAAO,CAAC4C,SAAS,CAAC,CAAC3B,MAAM,KAAK,QAAQ,EAAE;MACxC,OAAO2B,SAAS;IACpB;EACJ;EACA,OAAO,CAAC,CAAC,CAAC,CAAC;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASL,YAAYA,CAACT,SAAS,EAAE;EACpC;EACA,MAAMe,eAAe,GAAGf,SAAS,CAAC9B,OAAO,CAAC8C,IAAI,CAACC,CAAC,IAAIA,CAAC,CAAC9B,MAAM,KAAK,QAAQ,CAAC;EAE1E,IAAIa,SAAS,CAACT,KAAK,KAAK,WAAW,IAAIwB,eAAe,EAAE;IACpD,OAAOf,SAAS;EACpB;EAEA,MAAME,cAAc,GAAG,CAAC,GAAGF,SAAS,CAAC9B,OAAO,CAAC;EAC7C,MAAMmC,UAAU,GAAG,CAAC,GAAGL,SAAS,CAACN,OAAO,CAAC;;EAEzC;EACA,MAAMwB,WAAW,GAAGhB,cAAc,CAACiB,SAAS,CAACF,CAAC,IAAIA,CAAC,CAAChC,KAAK,KAAK,EAAE,CAAC;EACjE,IAAIiC,WAAW,IAAI,CAAC,EAAE;IAClBhB,cAAc,CAACgB,WAAW,CAAC,GAAG;MAC1B,GAAGhB,cAAc,CAACgB,WAAW,CAAC;MAC9B/B,MAAM,EAAE;IACZ,CAAC;IAEDkB,UAAU,CAAChB,IAAI,CAAC,GAAGa,cAAc,CAACgB,WAAW,CAAC,CAACrC,OAAO,GAAG,KAAK,GAAGqB,cAAc,CAACgB,WAAW,CAAC,CAACtC,IAAI,mCAAmC,CAAC;IAErI,OAAO;MACH,GAAGoB,SAAS;MACZT,KAAK,EAAE,UAAU;MACjBrB,OAAO,EAAEgC,cAAc;MACvBT,MAAM,EAAEyB,WAAW;MACnBxB,OAAO,EAAEW,UAAU;MACnBP,kBAAkB,EAAE;IACxB,CAAC;EACL;;EAEA;EACA,MAAMsB,eAAe,GAAGlB,cAAc,CAACmB,MAAM,CAACJ,CAAC,IAAIA,CAAC,CAAChC,KAAK,IAAI,EAAE,CAAC;EAEjE,IAAImC,eAAe,CAACP,MAAM,KAAK,CAAC,EAAE;IAC9BR,UAAU,CAAChB,IAAI,CAAC,sCAAsC,CAAC;IAEvD,OAAO;MACH,GAAGW,SAAS;MACZT,KAAK,EAAE,UAAU;MACjBrB,OAAO,EAAEgC,cAAc;MACvBT,MAAM,EAAE,IAAI;MACZC,OAAO,EAAEW,UAAU;MACnBP,kBAAkB,EAAE;IACxB,CAAC;EACL;;EAEA;EACA,IAAIwB,YAAY,GAAG,CAAC;EACpB,IAAIC,aAAa,GAAG,CAAC,CAAC;EAEtBH,eAAe,CAACI,OAAO,CAAC9C,MAAM,IAAI;IAC9B,IAAIA,MAAM,CAACO,KAAK,GAAGqC,YAAY,EAAE;MAC7BA,YAAY,GAAG5C,MAAM,CAACO,KAAK;MAC3BsC,aAAa,GAAG7C,MAAM,CAACC,EAAE;IAC7B;EACJ,CAAC,CAAC;;EAEF;EACA,MAAM8C,WAAW,GAAGL,eAAe,CAACC,MAAM,CAACJ,CAAC,IAAIA,CAAC,CAAChC,KAAK,KAAKqC,YAAY,CAAC;EAEzE,IAAIG,WAAW,CAACZ,MAAM,GAAG,CAAC,EAAE;IACxB,MAAMa,SAAS,GAAGD,WAAW,CAACE,GAAG,CAACV,CAAC,IAAIA,CAAC,CAACpC,OAAO,GAAG,KAAK,GAAGoC,CAAC,CAACrC,IAAI,CAAC,CAACgD,IAAI,CAAC,OAAO,CAAC;IAChFvB,UAAU,CAAChB,IAAI,CAAC,aAAaqC,SAAS,cAAcJ,YAAY,UAAU,CAAC;;IAE3E;IACAG,WAAW,CAACD,OAAO,CAAC9C,MAAM,IAAI;MAC1BwB,cAAc,CAACxB,MAAM,CAACC,EAAE,CAAC,GAAG;QACxB,GAAGuB,cAAc,CAACxB,MAAM,CAACC,EAAE,CAAC;QAC5BQ,MAAM,EAAE;MACZ,CAAC;IACL,CAAC,CAAC;;IAEF;IACAoC,aAAa,GAAGE,WAAW,CAAC,CAAC,CAAC,CAAC9C,EAAE;EACrC,CAAC,MAAM,IAAI4C,aAAa,KAAK,CAAC,CAAC,EAAE;IAC7BlB,UAAU,CAAChB,IAAI,CAAC,GAAGa,cAAc,CAACqB,aAAa,CAAC,CAAC1C,OAAO,GAAG,KAAK,GAAGqB,cAAc,CAACqB,aAAa,CAAC,CAAC3C,IAAI,yBAAyB0C,YAAY,GAAG,CAAC;IAE9IpB,cAAc,CAACqB,aAAa,CAAC,GAAG;MAC5B,GAAGrB,cAAc,CAACqB,aAAa,CAAC;MAChCpC,MAAM,EAAE;IACZ,CAAC;EACL;EAEA,OAAO;IACH,GAAGa,SAAS;IACZT,KAAK,EAAE,UAAU;IACjBrB,OAAO,EAAEgC,cAAc;IACvBT,MAAM,EAAE8B,aAAa;IACrB7B,OAAO,EAAEW,UAAU;IACnBP,kBAAkB,EAAE;EACxB,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAAS+B,YAAYA,CAAC7B,SAAS,EAAE;EACpC,IAAIA,SAAS,CAACT,KAAK,KAAK,SAAS,EAAE;IAC/B,OAAOS,SAAS;EACpB;EAEA,MAAMC,WAAW,GAAGD,SAAS,CAACR,kBAAkB;EAChD,MAAMd,MAAM,GAAGsB,SAAS,CAAC9B,OAAO,CAAC+B,WAAW,CAAC;;EAE7C;EACA,IAAIvB,MAAM,CAACG,OAAO,IAAIH,MAAM,CAACS,MAAM,KAAK,QAAQ,EAAE;IAC9C,OAAO;MACH,GAAGa,SAAS;MACZF,kBAAkB,EAAE;IACxB,CAAC;EACL;;EAEA;EACA;EACA;EACA;;EAEA,IAAIpB,MAAM,CAACO,KAAK,GAAG,EAAE,EAAE;IACnB;IACA,OAAOc,cAAc,CAACC,SAAS,EAAEtB,MAAM,EAAEuB,WAAW,CAAC;EACzD,CAAC,MAAM;IACH;IACA,IAAI6B,eAAe;IACnB,IAAIpD,MAAM,CAACO,KAAK,IAAI,EAAE,EAAE;MACpB6C,eAAe,GAAG,GAAG;IACzB,CAAC,MAAM,IAAIpD,MAAM,CAACO,KAAK,IAAI,EAAE,EAAE;MAC3B6C,eAAe,GAAG,GAAG;IACzB,CAAC,MAAM;MACHA,eAAe,GAAG,GAAG;IACzB;;IAEA;IACA,IAAIC,IAAI,CAACC,MAAM,CAAC,CAAC,GAAGF,eAAe,EAAE;MACjC,OAAO/B,cAAc,CAACC,SAAS,EAAEtB,MAAM,EAAEuB,WAAW,CAAC;IACzD,CAAC,MAAM;MACH,OAAOU,UAAU,CAACX,SAAS,EAAEtB,MAAM,EAAEuB,WAAW,CAAC;IACrD;EACJ;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}