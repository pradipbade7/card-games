{"ast":null,"code":"import { cardUtils } from '../../services/cardUtils';\n\n/**\n * Set up a new game with the specified number of players\n * @param {number} numPlayers - Number of players (including human)\n * @param {string} cardBackStyle - Style of card backs to use\n * @return {Object} Initial game state\n */\nexport function setupInitialGame(numPlayers, cardBackStyle = 'cardback') {\n  let deck = cardUtils.shuffle(cardUtils.generateDeck());\n  const players = [];\n  const initialLog = ['Game started!'];\n  for (let i = 0; i < numPlayers; i++) {\n    const playerName = i === 0 ? 'You' : `Bot ${i}`;\n    const {\n      drawn,\n      remaining\n    } = cardUtils.drawCards(deck, 1);\n    const drawnCard = drawn[0];\n    deck = remaining;\n    const player = {\n      id: i,\n      name: playerName,\n      isHuman: i === 0,\n      cards: [...drawn],\n      hiddenCards: i === 0 ? [] : [...drawn],\n      // Initial card is hidden for bots\n      visibleCards: i === 0 ? [...drawn] : [],\n      // Initial card is visible for human\n      total: cardUtils.calculateTotal(drawn),\n      status: 'active' // active, holding, eliminated, winner\n    };\n    players.push(player);\n    if (i === 0) {\n      initialLog.push(`You drew ${cardUtils.getCardName(drawnCard)}. Total: ${player.total}`);\n    } else {\n      initialLog.push(`${playerName} drew a card.`);\n    }\n  }\n  initialLog.push(\"Your turn.\");\n  return {\n    phase: 'playing',\n    players,\n    deck,\n    currentPlayerIndex: 0,\n    winner: null,\n    gameLog: initialLog,\n    gameId: Date.now(),\n    cardBackStyle\n  };\n}\n\n/**\n * Handle a player drawing a card from the deck\n * @param {Object} gameState - Current game state\n * @param {Object} player - Player drawing a card\n * @param {number} playerIndex - Index of player in gameState.players array\n * @return {Object} Updated game state\n */\nexport function handleDrawCard(gameState, player, playerIndex) {\n  if (gameState.phase !== 'playing' || player.status !== 'active') {\n    return gameState; // Can't draw if game is over or player isn't active\n  }\n  const updatedPlayers = [...gameState.players];\n  const {\n    drawn,\n    remaining\n  } = cardUtils.drawCards(gameState.deck, 1);\n  const drawnCard = drawn[0];\n  const newTotal = player.total + cardUtils.getCardValue(drawnCard);\n\n  // Update log messages\n  const updatedLog = [...gameState.gameLog];\n  if (player.isHuman) {\n    updatedLog.push(`You drew ${cardUtils.getCardName(drawnCard)}. Total: ${newTotal}`);\n  } else {\n    updatedLog.push(`${player.name} drew ${cardUtils.getCardName(drawnCard)}. Total: ${newTotal}`);\n  }\n\n  // Determine if player is eliminated (bust)\n  const isEliminated = newTotal > 17;\n\n  // Update player's cards and status\n  updatedPlayers[playerIndex] = {\n    ...player,\n    cards: [...player.cards, drawnCard],\n    visibleCards: [...player.visibleCards, drawnCard],\n    // Add drawn card to visible cards\n    total: newTotal,\n    status: isEliminated ? 'eliminated' : 'active'\n  };\n  if (isEliminated) {\n    updatedLog.push(`${player.isHuman ? 'You' : player.name} went over 17 and is eliminated!`);\n  }\n\n  // Check for instant win (exactly 17)\n  if (newTotal === 17) {\n    updatedPlayers[playerIndex] = {\n      ...updatedPlayers[playerIndex],\n      status: 'winner'\n    };\n    updatedLog.push(`${player.isHuman ? 'You' : player.name} got exactly 17 - an instant win!`);\n    return {\n      ...gameState,\n      phase: 'gameOver',\n      players: updatedPlayers,\n      deck: remaining,\n      winner: playerIndex,\n      gameLog: updatedLog\n    };\n  }\n\n  // Move to next player if current player is eliminated or if it's an AI player\n  let nextPlayerIndex = playerIndex;\n  if (isEliminated || !player.isHuman) {\n    nextPlayerIndex = findNextActivePlayerIndex(updatedPlayers, playerIndex);\n    if (nextPlayerIndex === -1) {\n      // No active players left, game is over\n      return checkGameEnd({\n        ...gameState,\n        phase: 'revealing',\n        players: updatedPlayers,\n        deck: remaining,\n        gameLog: [...updatedLog, \"All players have finished. Revealing results...\"]\n      });\n    } else {\n      updatedLog.push(`${updatedPlayers[nextPlayerIndex].isHuman ? 'Your' : updatedPlayers[nextPlayerIndex].name + \"'s\"} turn.`);\n    }\n  }\n  return {\n    ...gameState,\n    players: updatedPlayers,\n    deck: remaining,\n    currentPlayerIndex: nextPlayerIndex,\n    gameLog: updatedLog\n  };\n}\n\n/**\n * Handle a player holding their current total\n * @param {Object} gameState - Current game state\n * @param {Object} player - Player holding\n * @param {number} playerIndex - Index of player in gameState.players array\n * @return {Object} Updated game state\n */\nexport function handleHold(gameState, player, playerIndex) {\n  if (gameState.phase !== 'playing' || player.status !== 'active') {\n    return gameState; // Can't hold if game is over or player isn't active\n  }\n  if (player.total < 11) {\n    return gameState; // Can't hold below 11\n  }\n  const updatedPlayers = [...gameState.players];\n  const updatedLog = [...gameState.gameLog];\n\n  // Update player status to holding\n  updatedPlayers[playerIndex] = {\n    ...player,\n    status: 'holding'\n  };\n  updatedLog.push(`${player.isHuman ? 'You' : player.name} holds at ${player.total}.`);\n\n  // Move to next player\n  const nextPlayerIndex = findNextActivePlayerIndex(updatedPlayers, playerIndex);\n  if (nextPlayerIndex === -1) {\n    // No active players left, move to revealing phase\n    return checkGameEnd({\n      ...gameState,\n      phase: 'revealing',\n      players: updatedPlayers,\n      gameLog: [...updatedLog, \"All players have finished. Revealing results...\"]\n    });\n  }\n  updatedLog.push(`${updatedPlayers[nextPlayerIndex].isHuman ? 'Your' : updatedPlayers[nextPlayerIndex].name + \"'s\"} turn.`);\n  return {\n    ...gameState,\n    players: updatedPlayers,\n    currentPlayerIndex: nextPlayerIndex,\n    gameLog: updatedLog\n  };\n}\n\n/**\n * Find the index of the next active player\n * @param {Array} players - List of players\n * @param {number} currentIndex - Current player index\n * @return {number} Index of next active player, or -1 if none found\n */\nfunction findNextActivePlayerIndex(players, currentIndex) {\n  for (let i = 1; i <= players.length; i++) {\n    const nextIndex = (currentIndex + i) % players.length;\n    if (players[nextIndex].status === 'active') {\n      return nextIndex;\n    }\n  }\n  return -1; // No active players found\n}\n\n/**\n * Check if the game has ended and determine winner\n * @param {Object} gameState - Current game state\n * @return {Object} Updated game state with winner determined\n */\nexport function checkGameEnd(gameState) {\n  // Only proceed if we're in revealing phase or no active players remain\n  const hasActivePlayer = gameState.players.some(p => p.status === 'active');\n  if (gameState.phase !== 'revealing' && hasActivePlayer) {\n    return gameState;\n  }\n  const updatedPlayers = [...gameState.players];\n  const updatedLog = [...gameState.gameLog];\n\n  // Check if someone already won with exactly 17\n  const exactWinner = updatedPlayers.findIndex(p => p.total === 17);\n  if (exactWinner >= 0) {\n    updatedPlayers[exactWinner] = {\n      ...updatedPlayers[exactWinner],\n      status: 'winner'\n    };\n    updatedLog.push(`${updatedPlayers[exactWinner].isHuman ? 'You' : updatedPlayers[exactWinner].name} wins with a perfect score of 17!`);\n    return {\n      ...gameState,\n      phase: 'gameOver',\n      players: updatedPlayers,\n      winner: exactWinner,\n      gameLog: updatedLog\n    };\n  }\n\n  // Find eligible players (not eliminated)\n  const eligiblePlayers = updatedPlayers.filter(p => p.total <= 17);\n  if (eligiblePlayers.length === 0) {\n    updatedLog.push('No winner! All players went over 17.');\n    return {\n      ...gameState,\n      phase: 'gameOver',\n      players: updatedPlayers,\n      winner: null,\n      gameLog: updatedLog\n    };\n  }\n\n  // Find player with highest score\n  let highestScore = 0;\n  let winningPlayer = -1;\n  eligiblePlayers.forEach(player => {\n    if (player.total > highestScore) {\n      highestScore = player.total;\n      winningPlayer = player.id;\n    }\n  });\n\n  // Check for ties\n  const tiedPlayers = eligiblePlayers.filter(p => p.total === highestScore);\n  if (tiedPlayers.length > 1) {\n    const tiedNames = tiedPlayers.map(p => p.isHuman ? 'You' : p.name).join(' and ');\n    updatedLog.push(`Tie game! ${tiedNames} tied with ${highestScore} points.`);\n\n    // Mark all tied players as winners\n    tiedPlayers.forEach(player => {\n      updatedPlayers[player.id] = {\n        ...updatedPlayers[player.id],\n        status: 'winner'\n      };\n    });\n\n    // Use the first tied player as the \"primary\" winner\n    winningPlayer = tiedPlayers[0].id;\n  } else if (winningPlayer !== -1) {\n    updatedLog.push(`${updatedPlayers[winningPlayer].isHuman ? 'You' : updatedPlayers[winningPlayer].name} wins with a score of ${highestScore}!`);\n    updatedPlayers[winningPlayer] = {\n      ...updatedPlayers[winningPlayer],\n      status: 'winner'\n    };\n  }\n  return {\n    ...gameState,\n    phase: 'gameOver',\n    players: updatedPlayers,\n    winner: winningPlayer,\n    gameLog: updatedLog\n  };\n}\n\n/**\n * Handle AI player's turn\n * @param {Object} gameState - Current game state\n * @return {Object} Updated game state after AI's turn\n */\nexport function handleAITurn(gameState) {\n  if (gameState.phase !== 'playing') {\n    return gameState;\n  }\n  const playerIndex = gameState.currentPlayerIndex;\n  const player = gameState.players[playerIndex];\n\n  // Only handle if it's an AI player and they are active\n  if (player.isHuman || player.status !== 'active') {\n    return gameState;\n  }\n\n  // AI strategy: Always draw if below 11 (required)\n  // If 11-13, draw with 70% probability\n  // If 14-15, draw with 40% probability\n  // If 16-17, draw with 10% probability\n\n  if (player.total < 11) {\n    // Must draw if below 11\n    return handleDrawCard(gameState, player, playerIndex);\n  } else {\n    // Decision based on current total\n    let drawProbability;\n    if (player.total <= 13) {\n      drawProbability = 0.7;\n    } else if (player.total <= 15) {\n      drawProbability = 0.4;\n    } else {\n      drawProbability = 0.1;\n    }\n\n    // Make decision\n    if (Math.random() < drawProbability) {\n      return handleDrawCard(gameState, player, playerIndex);\n    } else {\n      return handleHold(gameState, player, playerIndex);\n    }\n  }\n}","map":{"version":3,"names":["cardUtils","setupInitialGame","numPlayers","cardBackStyle","deck","shuffle","generateDeck","players","initialLog","i","playerName","drawn","remaining","drawCards","drawnCard","player","id","name","isHuman","cards","hiddenCards","visibleCards","total","calculateTotal","status","push","getCardName","phase","currentPlayerIndex","winner","gameLog","gameId","Date","now","handleDrawCard","gameState","playerIndex","updatedPlayers","newTotal","getCardValue","updatedLog","isEliminated","nextPlayerIndex","findNextActivePlayerIndex","checkGameEnd","handleHold","currentIndex","length","nextIndex","hasActivePlayer","some","p","exactWinner","findIndex","eligiblePlayers","filter","highestScore","winningPlayer","forEach","tiedPlayers","tiedNames","map","join","handleAITurn","drawProbability","Math","random"],"sources":["/Users/pradipbade/Documents/Projects/Small Projects/react-3d-card-game/src/games/gameOf17/gameLogic.js"],"sourcesContent":["import { cardUtils } from '../../services/cardUtils';\n\n/**\n * Set up a new game with the specified number of players\n * @param {number} numPlayers - Number of players (including human)\n * @param {string} cardBackStyle - Style of card backs to use\n * @return {Object} Initial game state\n */\nexport function setupInitialGame(numPlayers, cardBackStyle = 'cardback') {\n    let deck = cardUtils.shuffle(cardUtils.generateDeck());\n    const players = [];\n    const initialLog = ['Game started!'];\n\n    for (let i = 0; i < numPlayers; i++) {\n        const playerName = i === 0 ? 'You' : `Bot ${i}`;\n        const { drawn, remaining } = cardUtils.drawCards(deck, 1);\n        const drawnCard = drawn[0];\n        deck = remaining;\n\n        const player = {\n            id: i,\n            name: playerName,\n            isHuman: i === 0,\n            cards: [...drawn],\n            hiddenCards: i === 0 ? [] : [...drawn], // Initial card is hidden for bots\n            visibleCards: i === 0 ? [...drawn] : [], // Initial card is visible for human\n            total: cardUtils.calculateTotal(drawn),\n            status: 'active' // active, holding, eliminated, winner\n        };\n\n        players.push(player);\n\n        if (i === 0) {\n            initialLog.push(`You drew ${cardUtils.getCardName(drawnCard)}. Total: ${player.total}`);\n        } else {\n            initialLog.push(`${playerName} drew a card.`);\n        }\n    }\n\n    initialLog.push(\"Your turn.\");\n\n    return {\n        phase: 'playing',\n        players,\n        deck,\n        currentPlayerIndex: 0,\n        winner: null,\n        gameLog: initialLog,\n        gameId: Date.now(),\n        cardBackStyle\n    };\n}\n\n/**\n * Handle a player drawing a card from the deck\n * @param {Object} gameState - Current game state\n * @param {Object} player - Player drawing a card\n * @param {number} playerIndex - Index of player in gameState.players array\n * @return {Object} Updated game state\n */\nexport function handleDrawCard(gameState, player, playerIndex) {\n    if (gameState.phase !== 'playing' || player.status !== 'active') {\n        return gameState; // Can't draw if game is over or player isn't active\n    }\n    \n    const updatedPlayers = [...gameState.players];\n    const { drawn, remaining } = cardUtils.drawCards(gameState.deck, 1);\n    const drawnCard = drawn[0];\n    const newTotal = player.total + cardUtils.getCardValue(drawnCard);\n    \n    // Update log messages\n    const updatedLog = [...gameState.gameLog];\n    if (player.isHuman) {\n        updatedLog.push(`You drew ${cardUtils.getCardName(drawnCard)}. Total: ${newTotal}`);\n    } else {\n        updatedLog.push(`${player.name} drew ${cardUtils.getCardName(drawnCard)}. Total: ${newTotal}`);\n    }\n    \n    // Determine if player is eliminated (bust)\n    const isEliminated = newTotal > 17;\n    \n    // Update player's cards and status\n    updatedPlayers[playerIndex] = {\n        ...player,\n        cards: [...player.cards, drawnCard],\n        visibleCards: [...player.visibleCards, drawnCard], // Add drawn card to visible cards\n        total: newTotal,\n        status: isEliminated ? 'eliminated' : 'active'\n    };\n    \n    if (isEliminated) {\n        updatedLog.push(`${player.isHuman ? 'You' : player.name} went over 17 and is eliminated!`);\n    }\n    \n    // Check for instant win (exactly 17)\n    if (newTotal === 17) {\n        updatedPlayers[playerIndex] = {\n            ...updatedPlayers[playerIndex],\n            status: 'winner'\n        };\n        \n        updatedLog.push(`${player.isHuman ? 'You' : player.name} got exactly 17 - an instant win!`);\n        \n        return {\n            ...gameState,\n            phase: 'gameOver',\n            players: updatedPlayers,\n            deck: remaining,\n            winner: playerIndex,\n            gameLog: updatedLog\n        };\n    }\n    \n    // Move to next player if current player is eliminated or if it's an AI player\n    let nextPlayerIndex = playerIndex;\n    if (isEliminated || !player.isHuman) {\n        nextPlayerIndex = findNextActivePlayerIndex(updatedPlayers, playerIndex);\n        \n        if (nextPlayerIndex === -1) {\n            // No active players left, game is over\n            return checkGameEnd({\n                ...gameState,\n                phase: 'revealing',\n                players: updatedPlayers,\n                deck: remaining,\n                gameLog: [...updatedLog, \"All players have finished. Revealing results...\"]\n            });\n        } else {\n            updatedLog.push(`${updatedPlayers[nextPlayerIndex].isHuman ? 'Your' : updatedPlayers[nextPlayerIndex].name + \"'s\"} turn.`);\n        }\n    }\n    \n    return {\n        ...gameState,\n        players: updatedPlayers,\n        deck: remaining,\n        currentPlayerIndex: nextPlayerIndex,\n        gameLog: updatedLog\n    };\n}\n\n/**\n * Handle a player holding their current total\n * @param {Object} gameState - Current game state\n * @param {Object} player - Player holding\n * @param {number} playerIndex - Index of player in gameState.players array\n * @return {Object} Updated game state\n */\nexport function handleHold(gameState, player, playerIndex) {\n    if (gameState.phase !== 'playing' || player.status !== 'active') {\n        return gameState; // Can't hold if game is over or player isn't active\n    }\n    \n    if (player.total < 11) {\n        return gameState; // Can't hold below 11\n    }\n    \n    const updatedPlayers = [...gameState.players];\n    const updatedLog = [...gameState.gameLog];\n    \n    // Update player status to holding\n    updatedPlayers[playerIndex] = {\n        ...player,\n        status: 'holding'\n    };\n    \n    updatedLog.push(`${player.isHuman ? 'You' : player.name} holds at ${player.total}.`);\n    \n    // Move to next player\n    const nextPlayerIndex = findNextActivePlayerIndex(updatedPlayers, playerIndex);\n    \n    if (nextPlayerIndex === -1) {\n        // No active players left, move to revealing phase\n        return checkGameEnd({\n            ...gameState,\n            phase: 'revealing',\n            players: updatedPlayers,\n            gameLog: [...updatedLog, \"All players have finished. Revealing results...\"]\n        });\n    }\n    \n    updatedLog.push(`${updatedPlayers[nextPlayerIndex].isHuman ? 'Your' : updatedPlayers[nextPlayerIndex].name + \"'s\"} turn.`);\n    \n    return {\n        ...gameState,\n        players: updatedPlayers,\n        currentPlayerIndex: nextPlayerIndex,\n        gameLog: updatedLog\n    };\n}\n\n/**\n * Find the index of the next active player\n * @param {Array} players - List of players\n * @param {number} currentIndex - Current player index\n * @return {number} Index of next active player, or -1 if none found\n */\nfunction findNextActivePlayerIndex(players, currentIndex) {\n    for (let i = 1; i <= players.length; i++) {\n        const nextIndex = (currentIndex + i) % players.length;\n        if (players[nextIndex].status === 'active') {\n            return nextIndex;\n        }\n    }\n    return -1; // No active players found\n}\n\n/**\n * Check if the game has ended and determine winner\n * @param {Object} gameState - Current game state\n * @return {Object} Updated game state with winner determined\n */\nexport function checkGameEnd(gameState) {\n    // Only proceed if we're in revealing phase or no active players remain\n    const hasActivePlayer = gameState.players.some(p => p.status === 'active');\n    \n    if (gameState.phase !== 'revealing' && hasActivePlayer) {\n        return gameState;\n    }\n    \n    const updatedPlayers = [...gameState.players];\n    const updatedLog = [...gameState.gameLog];\n    \n    // Check if someone already won with exactly 17\n    const exactWinner = updatedPlayers.findIndex(p => p.total === 17);\n    if (exactWinner >= 0) {\n        updatedPlayers[exactWinner] = {\n            ...updatedPlayers[exactWinner],\n            status: 'winner'\n        };\n        \n        updatedLog.push(`${updatedPlayers[exactWinner].isHuman ? 'You' : updatedPlayers[exactWinner].name} wins with a perfect score of 17!`);\n        \n        return {\n            ...gameState,\n            phase: 'gameOver',\n            players: updatedPlayers,\n            winner: exactWinner,\n            gameLog: updatedLog\n        };\n    }\n    \n    // Find eligible players (not eliminated)\n    const eligiblePlayers = updatedPlayers.filter(p => p.total <= 17);\n    \n    if (eligiblePlayers.length === 0) {\n        updatedLog.push('No winner! All players went over 17.');\n        \n        return {\n            ...gameState,\n            phase: 'gameOver',\n            players: updatedPlayers,\n            winner: null,\n            gameLog: updatedLog\n        };\n    }\n    \n    // Find player with highest score\n    let highestScore = 0;\n    let winningPlayer = -1;\n    \n    eligiblePlayers.forEach(player => {\n        if (player.total > highestScore) {\n            highestScore = player.total;\n            winningPlayer = player.id;\n        }\n    });\n    \n    // Check for ties\n    const tiedPlayers = eligiblePlayers.filter(p => p.total === highestScore);\n    \n    if (tiedPlayers.length > 1) {\n        const tiedNames = tiedPlayers.map(p => p.isHuman ? 'You' : p.name).join(' and ');\n        updatedLog.push(`Tie game! ${tiedNames} tied with ${highestScore} points.`);\n        \n        // Mark all tied players as winners\n        tiedPlayers.forEach(player => {\n            updatedPlayers[player.id] = {\n                ...updatedPlayers[player.id],\n                status: 'winner'\n            };\n        });\n        \n        // Use the first tied player as the \"primary\" winner\n        winningPlayer = tiedPlayers[0].id;\n    } else if (winningPlayer !== -1) {\n        updatedLog.push(`${updatedPlayers[winningPlayer].isHuman ? 'You' : updatedPlayers[winningPlayer].name} wins with a score of ${highestScore}!`);\n        \n        updatedPlayers[winningPlayer] = {\n            ...updatedPlayers[winningPlayer],\n            status: 'winner'\n        };\n    }\n    \n    return {\n        ...gameState,\n        phase: 'gameOver',\n        players: updatedPlayers,\n        winner: winningPlayer,\n        gameLog: updatedLog\n    };\n}\n\n/**\n * Handle AI player's turn\n * @param {Object} gameState - Current game state\n * @return {Object} Updated game state after AI's turn\n */\nexport function handleAITurn(gameState) {\n    if (gameState.phase !== 'playing') {\n        return gameState;\n    }\n    \n    const playerIndex = gameState.currentPlayerIndex;\n    const player = gameState.players[playerIndex];\n    \n    // Only handle if it's an AI player and they are active\n    if (player.isHuman || player.status !== 'active') {\n        return gameState;\n    }\n    \n    // AI strategy: Always draw if below 11 (required)\n    // If 11-13, draw with 70% probability\n    // If 14-15, draw with 40% probability\n    // If 16-17, draw with 10% probability\n    \n    if (player.total < 11) {\n        // Must draw if below 11\n        return handleDrawCard(gameState, player, playerIndex);\n    } else {\n        // Decision based on current total\n        let drawProbability;\n        if (player.total <= 13) {\n            drawProbability = 0.7;\n        } else if (player.total <= 15) {\n            drawProbability = 0.4;\n        } else {\n            drawProbability = 0.1;\n        }\n        \n        // Make decision\n        if (Math.random() < drawProbability) {\n            return handleDrawCard(gameState, player, playerIndex);\n        } else {\n            return handleHold(gameState, player, playerIndex);\n        }\n    }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}